#! /bin/sh
if expr a : '\(a\)' >/dev/null 2>&1; then
  as_expr=expr
else
  as_expr=false
fi



## --------------------- ##
## M4sh Initialization.  ##
## --------------------- ##

# Be Bourne compatible
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
  set -o posix
fi

# NLS nuisances.
# Support unset when possible.
if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
  as_unset=unset
else
  as_unset=false
fi

(set +x; test -n "`(LANG=C; export LANG) 2>&1`") &&
    { $as_unset LANG || test "${LANG+set}" != set; } ||
      { LANG=C; export LANG; }
(set +x; test -n "`(LC_ALL=C; export LC_ALL) 2>&1`") &&
    { $as_unset LC_ALL || test "${LC_ALL+set}" != set; } ||
      { LC_ALL=C; export LC_ALL; }
(set +x; test -n "`(LC_TIME=C; export LC_TIME) 2>&1`") &&
    { $as_unset LC_TIME || test "${LC_TIME+set}" != set; } ||
      { LC_TIME=C; export LC_TIME; }
(set +x; test -n "`(LC_CTYPE=C; export LC_CTYPE) 2>&1`") &&
    { $as_unset LC_CTYPE || test "${LC_CTYPE+set}" != set; } ||
      { LC_CTYPE=C; export LC_CTYPE; }
(set +x; test -n "`(LANGUAGE=C; export LANGUAGE) 2>&1`") &&
    { $as_unset LANGUAGE || test "${LANGUAGE+set}" != set; } ||
      { LANGUAGE=C; export LANGUAGE; }
(set +x; test -n "`(LC_COLLATE=C; export LC_COLLATE) 2>&1`") &&
    { $as_unset LC_COLLATE || test "${LC_COLLATE+set}" != set; } ||
      { LC_COLLATE=C; export LC_COLLATE; }
(set +x; test -n "`(LC_NUMERIC=C; export LC_NUMERIC) 2>&1`") &&
    { $as_unset LC_NUMERIC || test "${LC_NUMERIC+set}" != set; } ||
      { LC_NUMERIC=C; export LC_NUMERIC; }
(set +x; test -n "`(LC_MESSAGES=C; export LC_MESSAGES) 2>&1`") &&
    { $as_unset LC_MESSAGES || test "${LC_MESSAGES+set}" != set; } ||
      { LC_MESSAGES=C; export LC_MESSAGES; }


# Name of the executable.
as_me=`(basename "$0") 2>/dev/null ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)$' \| \
	 .     : '\(.\)' 2>/dev/null ||
echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
  	  /^X\/\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`

# PATH needs CR, and LINENO needs CR and PATH.
# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  echo "#! /bin/sh" >conftest.sh
  echo  "exit 0"   >>conftest.sh
  chmod +x conftest.sh
  if (PATH=".;."; conftest.sh) >/dev/null 2>&1; then
    PATH_SEPARATOR=';'
  else
    PATH_SEPARATOR=:
  fi
  rm -f conftest.sh
fi


  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
  # Find who we are.  Look in the path if we contain no path at all
  # relative or not.
  case $0 in
    *[\\/]* ) as_myself=$0 ;;
    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
done

       ;;
  esac
  # We did not find ourselves, most probably we were run as `sh COMMAND'
  # in which case we are not to be found in the path.
  if test "x$as_myself" = x; then
    as_myself=$0
  fi
  if test ! -f "$as_myself"; then
    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
   { (exit 1); exit 1; }; }
  fi
  case $CONFIG_SHELL in
  '')
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  for as_base in sh bash ksh sh5; do
	 case $as_dir in
	 /*)
	   if ("$as_dir/$as_base" -c '
  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
	     CONFIG_SHELL=$as_dir/$as_base
	     export CONFIG_SHELL
	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
	   fi;;
	 esac
       done
done
;;
  esac

  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
  # uniformly replaced by the line number.  The first 'sed' inserts a
  # line-number line before each line; the second 'sed' does the real
  # work.  The second script uses 'N' to pair each line-number line
  # with the numbered line, and appends trailing '-' during
  # substitution so that $LINENO is not a special case at line end.
  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
  sed '=' <$as_myself |
    sed '
      N
      s,$,-,
      : loop
      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
      t loop
      s,-$,,
      s,^['$as_cr_digits']*\n,,
    ' >$as_me.lineno &&
  chmod +x $as_me.lineno ||
    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
   { (exit 1); exit 1; }; }

  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensible to this).
  . ./$as_me.lineno
  # Exit status is that of the last command.
  exit
}


case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
  *c*,-n*) ECHO_N= ECHO_C='
' ECHO_T='	' ;;
  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
esac

if expr a : '\(a\)' >/dev/null 2>&1; then
  as_expr=expr
else
  as_expr=false
fi

rm -f conf$$ conf$$.exe conf$$.file
echo >conf$$.file
if ln -s conf$$.file conf$$ 2>/dev/null; then
  # We could just check for DJGPP; but this test a) works b) is more generic
  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
  if test -f conf$$.exe; then
    # Don't use ln at all; we don't have any links
    as_ln_s='cp -p'
  else
    as_ln_s='ln -s'
  fi
elif ln conf$$.file conf$$ 2>/dev/null; then
  as_ln_s=ln
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.file

as_executable_p="test -f"

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"


# IFS
# We need space, tab and new line, in precisely that order.
as_nl='
'
IFS=" 	$as_nl"

# CDPATH.
$as_unset CDPATH || test "${CDPATH+set}" != set || { CDPATH=$PATH_SEPARATOR; export CDPATH; }

SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args=${1+"$@"}

# Load the config file.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || { echo "$as_me: error: invalid content: $at_file" >&2
   { (exit 1); exit 1; }; }
done

# atconfig delivers paths relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir in srcdir top_srcdir top_builddir
  do
    at_val=`eval echo '${'at_$at_dir'}'`
    eval "$at_dir=$at_val/../.."
  done
fi

# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_skip=:
(times) >/dev/null 2>&1 && at_times_skip=false

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?
at_verbose=:
at_quiet=echo

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# List test groups?
at_list_p=false
# Test groups to run
at_groups=

# The directory we are in.
at_dir=`pwd`
# The directory the whole suite works in.
# Should be absolutely to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the location of the last AT_CHECK.
at_check_line_file=$at_suite_dir/at-check-line
# The files containing the output of the tested commands.
at_stdout=$at_suite_dir/at-stdout
at_stder1=$at_suite_dir/at-stder1
at_stderr=$at_suite_dir/at-stderr
# The file containing dates.
at_times_file=$at_suite_dir/at-times

# List of the tested programs.
at_tested='bison'
# List of the all the test groups.
at_groups_all=' banner-1 1 2 banner-2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 banner-3 20 21 banner-4 22 23 24 25 banner-5 26 27 28 29 30 31 32 33 34 35 36 banner-6 37 38 39 40 banner-7 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56'
# As many dots as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='..'
# Description of all the test groups.
at_help_all=
at_help_all=$at_help_all'1;input.at:28;Invalid $n;
'
at_help_all=$at_help_all'2;input.at:47;Invalid @n;
'
at_help_all=$at_help_all'3;output.at:38;Output files:  & -dv.;
'
at_help_all=$at_help_all'4;output.at:40;Output files:  & -dv -o foo.c.;
'
at_help_all=$at_help_all'5;output.at:42;Output files:  & -dv -o foo.tab.c.;
'
at_help_all=$at_help_all'6;output.at:44;Output files:  & -dv -y.;
'
at_help_all=$at_help_all'7;output.at:46;Output files:  & -dv -b bar.;
'
at_help_all=$at_help_all'8;output.at:48;Output files:  & -dv -g -o foo.c.;
'
at_help_all=$at_help_all'9;output.at:52;Output files: %defines %verbose & .;
'
at_help_all=$at_help_all'10;output.at:54;Output files: %defines %verbose %yacc & .;
'
at_help_all=$at_help_all'11;output.at:57;Output files: %defines %verbose %yacc & .;
'
at_help_all=$at_help_all'12;output.at:61;Output files: %file-prefix="bar" %defines %verbose & .;
'
at_help_all=$at_help_all'13;output.at:63;Output files: %output="bar.c" %defines %verbose %yacc & .;
'
at_help_all=$at_help_all'14;output.at:67;Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & .;
'
at_help_all=$at_help_all'15;output.at:72;Output files: %defines %verbose & .;
'
at_help_all=$at_help_all'16;output.at:75;Output files: %defines %verbose  & -o foo.c.;
'
at_help_all=$at_help_all'17;output.at:79;Output files:  & --defines=foo.hpp -o foo.c++.;
'
at_help_all=$at_help_all'18;output.at:83;Output files:  & -o foo.c++ --graph=foo.gph.;
'
at_help_all=$at_help_all'19;output.at:87;Clashing Output Files;
'
at_help_all=$at_help_all'20;sets.at:26;Nullable;
'
at_help_all=$at_help_all'21;sets.at:160;Broken Closure;
'
at_help_all=$at_help_all'22;reduce.at:26;Useless Terminals;
'
at_help_all=$at_help_all'23;reduce.at:70;Useless Nonterminals;
'
at_help_all=$at_help_all'24;reduce.at:116;Useless Rules;
'
at_help_all=$at_help_all'25;reduce.at:180;Underivable Rules;
'
at_help_all=$at_help_all'26;calc.at:385;Calculator ;
'
at_help_all=$at_help_all'27;calc.at:387;Calculator --defines;
'
at_help_all=$at_help_all'28;calc.at:388;Calculator --locations;
'
at_help_all=$at_help_all'29;calc.at:389;Calculator --name-prefix=calc;
'
at_help_all=$at_help_all'30;calc.at:390;Calculator --verbose;
'
at_help_all=$at_help_all'31;calc.at:391;Calculator --yacc;
'
at_help_all=$at_help_all'32;calc.at:392;Calculator --yyerror-verbose;
'
at_help_all=$at_help_all'33;calc.at:394;Calculator --locations --yyerror-verbose;
'
at_help_all=$at_help_all'34;calc.at:396;Calculator --defines --locations --name-prefix=calc --verbose --yacc --yyerror-verbose;
'
at_help_all=$at_help_all'35;calc.at:398;Calculator --debug;
'
at_help_all=$at_help_all'36;calc.at:399;Calculator --debug --defines --locations --name-prefix=calc --verbose --yacc --yyerror-verbose;
'
at_help_all=$at_help_all'37;torture.at:83;Exploding the Stack Size with Alloca;
'
at_help_all=$at_help_all'38;torture.at:104;Exploding the Stack Size with Malloc;
'
at_help_all=$at_help_all'39;torture.at:123;GNU AWK Grammar;
'
at_help_all=$at_help_all'40;torture.at:463;GNU Cim Grammar;
'
at_help_all=$at_help_all'41;regression.at:26;%nonassoc and eof;
'
at_help_all=$at_help_all'42;regression.at:100;braces parsing;
'
at_help_all=$at_help_all'43;regression.at:122;Duplicate string;
'
at_help_all=$at_help_all'44;regression.at:146;Unresolved SR Conflicts;
'
at_help_all=$at_help_all'45;regression.at:251;Solved SR Conflicts;
'
at_help_all=$at_help_all'46;regression.at:356;Rule Line Numbers;
'
at_help_all=$at_help_all'47;regression.at:500;%expect not enough;
'
at_help_all=$at_help_all'48;regression.at:520;%expect right;
'
at_help_all=$at_help_all'49;regression.at:537;%expect too much;
'
at_help_all=$at_help_all'50;regression.at:558;Mixing %token styles;
'
at_help_all=$at_help_all'51;regression.at:581;%union and --defines;
'
at_help_all=$at_help_all'52;regression.at:603;%union and C comments;
'
at_help_all=$at_help_all'53;regression.at:626;Invalid inputs;
'
at_help_all=$at_help_all'54;regression.at:656;Invalid %directive;
'
at_help_all=$at_help_all'55;regression.at:681;Web2c Report;
'
at_help_all=$at_help_all'56;regression.at:798;Web2c Actions;
'



while test $# -gt 0; do
  case $1 in
    --help | -h )
        at_help_p=:
        ;;

    --list | -l )
        at_list_p=:
        ;;

    --version | -V )
        echo "$as_me (GNU Bison 1.35)"
        exit 0
        ;;

    --clean | -c )
        rm -rf $at_suite_dir $as_me.log
        exit 0
        ;;

    --debug | -d )
        at_debug_p=:
        ;;

    --errexit | -e )
        at_debug_p=:
        at_errexit_p=:
        ;;

    --verbose | -v )
        at_verbose=echo; at_quiet=:
        ;;

    --trace | -x )
        at_traceon='set -vx'; at_traceoff='set +vx'
        ;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
        at_groups="$at_groups$1 "
        ;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
        at_range_start=`echo $1 |tr -d '-'`
        at_range=`echo " $at_groups_all " | \
          sed -e 's,^.* '$at_range_start' ,'$at_range_start' ,'`
        at_groups="$at_groups$at_range "
        ;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
        at_range_end=`echo $1 |tr -d '-'`
        at_range=`echo " $at_groups_all " | \
          sed -e 's, '$at_range_end' .*$, '$at_range_end','`
        at_groups="$at_groups$at_range "
        ;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
        at_range_start=`echo $1 |sed 's,-.*,,'`
        at_range_end=`echo $1 |sed 's,.*-,,'`
        # FIXME: Maybe test to make sure start <= end?
        at_range=`echo " $at_groups_all " | \
          sed -e 's,^.* '$at_range_start' ,'$at_range_start' ,' \
              -e 's, '$at_range_end' .*$, '$at_range_end','`
        at_groups="$at_groups$at_range "
        ;;

    # Keywords.
    --keywords | -k )
        shift
        at_groups_selected=$at_help_all
        for at_keyword in `IFS=,; set X $1; shift; echo ${1+$@}`
        do
          # It is on purpose that we match the test group titles too.
          at_groups_selected=`echo "$at_groups_selected" |
                             egrep -i "^[^;]*;[^;]*;.*$at_keyword"`
        done
        at_groups_selected=`echo "$at_groups_selected" | sed 's/;.*//'`
	# Smash the end of lines.
	at_groups_selected=`echo $at_groups_selected`
        at_groups="$at_groups$at_groups_selected "
        ;;

    *=*)
  	at_envvar=`expr "x$1" : 'x\([^=]*\)='`
  	# Reject names that are not valid shell variable names.
  	expr "x$at_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
  	  { echo "$as_me: error: invalid variable name: $at_envvar" >&2
   { (exit 1); exit 1; }; }
  	at_value=`expr "x$1" : 'x[^=]*=\(.*\)'`
  	at_value=`echo "$at_value" | sed "s/'/'\\\\\\\\''/g"`
  	eval "$at_envvar='$at_value'"
  	export $at_envvar
	# Propagate to debug scripts.
  	at_debug_args="$at_debug_args $1"
  	;;

     *) echo "$as_me: invalid option: $1" >&2
        echo "Try \`$0 --help' for more information." >&2
        exit 1
        ;;
  esac
  shift
done

# Selected test groups.
test -z "$at_groups" && at_groups=$at_groups_all

# Help message.
if $at_help_p; then
  cat <<_ATEOF
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, and save a detailed log file.
Upon failure, create debugging scripts.

You should not change environment variables unless explicitly passed
as command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relatively to the top level of this distribution.  E.g.,

  $ $0 AUTOTEST_PATH=bin

possibly amounts into

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS

Execution tuning:
  -k, --keywords=KEYWORDS
                 select the tests matching all the comma separated KEYWORDS
                 accumulates
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
                 default for debugging scripts
  -d, --debug    inhibit clean up and debug script creation
                 default for debugging scripts
  -x, --trace    enable tests shell tracing

Report bugs to <bug-bison@gnu.org>.
_ATEOF
  exit 0
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF
GNU Bison 1.35 test suite test groups:

 NUM: FILENAME:LINE      TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # "  1 42  45 " => "^(1|42|45);".
  at_groups_pattern=`echo "$at_groups" | sed 's/^  *//;s/  *$//;s/  */|/g'`
  at_groups_pattern="^(${at_groups_pattern});"
  echo "$at_help_all" |
    egrep -e "$at_groups_pattern" |
    awk 'BEGIN { FS = ";" }
         { if ($1) printf " %3d: %-18s %s\n", $1, $2, $3
           if ($4) printf "      %s\n", $4 } '
  exit 0
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites, AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
AUTOTEST_PATH=`echo $AUTOTEST_PATH | tr ':' $PATH_SEPARATOR`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  case $as_dir in
  [\\/]* | ?:[\\/]* )
    at_path=$at_path$PATH_SEPARATOR$as_dir
    ;;
  * )
    if test -z "$at_top_builddir"; then
      # Stand-alone test suite.
      at_path=$at_path$PATH_SEPARATOR$as_dir
    else
      # Embedded test suite.
      at_path=$at_path$PATH_SEPARATOR$at_top_builddir/$as_dir
      at_path=$at_path$PATH_SEPARATOR$at_top_srcdir/$as_dir
    fi
    ;;
esac
done


# Now build and simplify PATH.
PATH=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  as_dir=`(cd "$as_dir" && pwd) 2>/dev/null`
test -d "$as_dir" || continue
case $PATH in
                  $as_dir                 | \
                  $as_dir$PATH_SEPARATOR* | \
  *$PATH_SEPARATOR$as_dir                 | \
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR* ) ;;

  '') PATH=$as_dir ;;
   *) PATH=$PATH$PATH_SEPARATOR$as_dir ;;
esac
done

export PATH

# Setting up the FDs.
# 5 is stdout conditioned by verbosity.
if test $at_verbose = echo; then
  exec 5>&1
else
  exec 5>/dev/null
fi

# 6 is the log file.  To be preserved if `-d'.

if $at_debug_p; then
  exec 6>/dev/null
else
  exec 6>$as_me.log
fi

# Banners and logs.
cat <<\_ASBOX
## -------------------------- ##
## GNU Bison 1.35 test suite. ##
## -------------------------- ##
_ASBOX
{
  cat <<\_ASBOX
## -------------------------- ##
## GNU Bison 1.35 test suite. ##
## -------------------------- ##
_ASBOX
  echo

  echo "$as_me: command line was:"
  echo "  $ $0 $at_cli_args"
  echo

  # Try to find a few ChangeLogs in case it might help determining the
  # exact version.  Use the relative dir: if the top dir is a symlink,
  # find will not follow it (and options to follow the links are not
  # portable), which would result in no output here.
  if test -n "$at_top_srcdir"; then
    cat <<\_ASBOX
## ----------- ##
## ChangeLogs. ##
## ----------- ##
_ASBOX
    echo
    for at_file in `find "$at_top_srcdir" -name ChangeLog -print`
    do
      echo "$as_me: $at_file:"
      sed 's/^/| /;10q' $at_file
      echo
    done

    {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  echo "PATH: $as_dir"
done

}
    echo
  fi

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    echo "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done

  cat <<\_ASBOX
## ---------------- ##
## Tested programs. ##
## ---------------- ##
_ASBOX
  echo
} >&6

# Report what programs are being tested.
for at_program in : $at_tested
do
  test "$at_program" = : && continue
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -f $as_dir/$at_program && break
done

  if test -f $as_dir/$at_program; then
    {
      echo "testsuite.at:24: $as_dir/$at_program --version"
      $as_dir/$at_program --version
      echo
    } >&6 2>&1
  else
    { { echo "$as_me:$LINENO: error: cannot find $at_program" >&6
echo "$as_me: error: cannot find $at_program" >&2;}
   { (exit 1); exit 1; }; }
  fi
done

{
  cat <<\_ASBOX
## --------------------------- ##
## Silently running the tests. ##
## --------------------------- ##
_ASBOX
} >&6

at_start_date=`date`
at_start_time=`(date +%s) 2>/dev/null`
echo "$as_me: starting at: $at_start_date" >&6
at_pass_list=
at_fail_list=
at_skip_list=
at_group_count=0

# Create the master directory if it doesn't already exist.
test -d $at_suite_dir ||
  mkdir $at_suite_dir ||
  { { echo "$as_me:$LINENO: error: cannot create $at_suite_dir" >&6
echo "$as_me: error: cannot create $at_suite_dir" >&2;}
   { (exit 1); exit 1; }; }

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  cp /dev/null $at_devnull
fi

# Use `diff -u' when possible.
if diff -u $at_devnull $at_devnull >/dev/null 2>&1; then
  at_diff='diff -u'
else
  at_diff=diff
fi


for at_group in $at_groups
do
  # Be sure to come back to the top test directory.
  cd $at_suite_dir

  case $at_group in
    banner-*) ;;
    *)
     # Skip tests we already run (using --keywords makes it easy to get
     # duplication).
     case " $at_pass_test $at_skip_test $at_fail_test " in
       *" $at_group "* ) continue;;
     esac

     # Normalize the test group number.
     at_group_normalized=`expr "00000$at_group" : ".*\($at_format\)"`

     # Create a fresh directory for the next test group, and enter.
     at_group_dir=$at_suite_dir/$at_group_normalized
     rm -rf $at_group_dir
     mkdir $at_group_dir ||
       { { echo "$as_me:$LINENO: error: cannot create $at_group_dir" >&6
echo "$as_me: error: cannot create $at_group_dir" >&2;}
   { (exit 1); exit 1; }; }
     cd $at_group_dir
    ;;
  esac

  at_status=0
  # Clearly separate the test groups when verbose.
  test $at_group_count != 0 && $at_verbose
  case $at_group in

  banner-1 ) # Banner 1. input.at:19
    cat <<\_ATEOF

Input Processing.

_ATEOF
    ;;

  1 ) # 1. input.at:28: Invalid $n
    at_setup_line='input.at:28'
    $at_verbose "1. input.at:28: testing Invalid $n..."
    $at_quiet $ECHO_N "  1: input.at:28       $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
exp: { $$ = $1 ; };
_ATEOF


$at_traceoff
$at_verbose "input.at:37: bison input.y"
echo input.at:37 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:2: invalid \$ value
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "input.at:37: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  2 ) # 2. input.at:47: Invalid @n
    at_setup_line='input.at:47'
    $at_verbose "2. input.at:47: testing Invalid @n..."
    $at_quiet $ECHO_N "  2: input.at:47       $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
exp: { @$ = @1 ; };
_ATEOF


$at_traceoff
$at_verbose "input.at:56: bison input.y"
echo input.at:56 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:2: invalid @ value
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "input.at:56: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-2 ) # Banner 2. output.at:19
    cat <<\_ATEOF

Output file names.

_ATEOF
    ;;

  3 ) # 3. output.at:38: Output files:  & -dv.
    at_setup_line='output.at:38'
    $at_verbose "3. output.at:38: testing Output files:  & -dv...."
    $at_quiet $ECHO_N "  3: output.at:38      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:38: bison -dv foo.y"
echo output.at:38 >$at_check_line_file
( $at_traceon; bison -dv foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:38: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:38: ls foo.output foo.tab.c foo.tab.h"
echo output.at:38 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:38: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  4 ) # 4. output.at:40: Output files:  & -dv -o foo.c.
    at_setup_line='output.at:40'
    $at_verbose "4. output.at:40: testing Output files:  & -dv -o foo.c...."
    $at_quiet $ECHO_N "  4: output.at:40      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:40: bison -dv -o foo.c foo.y"
echo output.at:40 >$at_check_line_file
( $at_traceon; bison -dv -o foo.c foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:40: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:40: ls foo.c foo.h foo.output"
echo output.at:40 >$at_check_line_file
( $at_traceon; ls foo.c foo.h foo.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:40: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  5 ) # 5. output.at:42: Output files:  & -dv -o foo.tab.c.
    at_setup_line='output.at:42'
    $at_verbose "5. output.at:42: testing Output files:  & -dv -o foo.tab.c...."
    $at_quiet $ECHO_N "  5: output.at:42      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:42: bison -dv -o foo.tab.c foo.y"
echo output.at:42 >$at_check_line_file
( $at_traceon; bison -dv -o foo.tab.c foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:42: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:42: ls foo.output foo.tab.c foo.tab.h"
echo output.at:42 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:42: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  6 ) # 6. output.at:44: Output files:  & -dv -y.
    at_setup_line='output.at:44'
    $at_verbose "6. output.at:44: testing Output files:  & -dv -y...."
    $at_quiet $ECHO_N "  6: output.at:44      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:44: bison -dv -y foo.y"
echo output.at:44 >$at_check_line_file
( $at_traceon; bison -dv -y foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:44: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:44: ls y.output y.tab.c y.tab.h"
echo output.at:44 >$at_check_line_file
( $at_traceon; ls y.output y.tab.c y.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:44: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  7 ) # 7. output.at:46: Output files:  & -dv -b bar.
    at_setup_line='output.at:46'
    $at_verbose "7. output.at:46: testing Output files:  & -dv -b bar...."
    $at_quiet $ECHO_N "  7: output.at:46      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:46: bison -dv -b bar foo.y"
echo output.at:46 >$at_check_line_file
( $at_traceon; bison -dv -b bar foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:46: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:46: ls bar.output bar.tab.c bar.tab.h"
echo output.at:46 >$at_check_line_file
( $at_traceon; ls bar.output bar.tab.c bar.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:46: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  8 ) # 8. output.at:48: Output files:  & -dv -g -o foo.c.
    at_setup_line='output.at:48'
    $at_verbose "8. output.at:48: testing Output files:  & -dv -g -o foo.c...."
    $at_quiet $ECHO_N "  8: output.at:48      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:48: bison -dv -g -o foo.c foo.y"
echo output.at:48 >$at_check_line_file
( $at_traceon; bison -dv -g -o foo.c foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:48: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:48: ls foo.c foo.h foo.output foo.vcg"
echo output.at:48 >$at_check_line_file
( $at_traceon; ls foo.c foo.h foo.output foo.vcg ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:48: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  9 ) # 9. output.at:52: Output files: %defines %verbose & .
    at_setup_line='output.at:52'
    $at_verbose "9. output.at:52: testing Output files: %defines %verbose & ...."
    $at_quiet $ECHO_N "  9: output.at:52      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:52: bison  foo.y"
echo output.at:52 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:52: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:52: ls foo.output foo.tab.c foo.tab.h"
echo output.at:52 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:52: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  10 ) # 10. output.at:54: Output files: %defines %verbose %yacc & .
    at_setup_line='output.at:54'
    $at_verbose "10. output.at:54: testing Output files: %defines %verbose %yacc & ...."
    $at_quiet $ECHO_N " 10: output.at:54      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:54: bison  foo.y"
echo output.at:54 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:54: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:54: ls y.output y.tab.c y.tab.h"
echo output.at:54 >$at_check_line_file
( $at_traceon; ls y.output y.tab.c y.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:54: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  11 ) # 11. output.at:57: Output files: %defines %verbose %yacc & .
    at_setup_line='output.at:57'
    $at_verbose "11. output.at:57: testing Output files: %defines %verbose %yacc & ...."
    $at_quiet $ECHO_N " 11: output.at:57      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:57: bison  foo.yy"
echo output.at:57 >$at_check_line_file
( $at_traceon; bison  foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:57: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:57: ls y.output y.tab.c y.tab.h"
echo output.at:57 >$at_check_line_file
( $at_traceon; ls y.output y.tab.c y.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:57: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  12 ) # 12. output.at:61: Output files: %file-prefix="bar" %defines %verbose & .
    at_setup_line='output.at:61'
    $at_verbose "12. output.at:61: testing Output files: %file-prefix="bar" %defines %verbose & ...."
    $at_quiet $ECHO_N " 12: output.at:61      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%file-prefix="bar" %defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:61: bison  foo.y"
echo output.at:61 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:61: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:61: ls bar.output bar.tab.c bar.tab.h"
echo output.at:61 >$at_check_line_file
( $at_traceon; ls bar.output bar.tab.c bar.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:61: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  13 ) # 13. output.at:63: Output files: %output="bar.c" %defines %verbose %yacc & .
    at_setup_line='output.at:63'
    $at_verbose "13. output.at:63: testing Output files: %output="bar.c" %defines %verbose %yacc & ...."
    $at_quiet $ECHO_N " 13: output.at:63      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%output="bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:63: bison  foo.y"
echo output.at:63 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:63: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:63: ls bar.output bar.c bar.h"
echo output.at:63 >$at_check_line_file
( $at_traceon; ls bar.output bar.c bar.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:63: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  14 ) # 14. output.at:67: Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & .
    at_setup_line='output.at:67'
    $at_verbose "14. output.at:67: testing Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & ...."
    $at_quiet $ECHO_N " 14: output.at:67      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%file-prefix="baz" %output="bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:67: bison  foo.y"
echo output.at:67 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:67: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:67: ls bar.output bar.c bar.h"
echo output.at:67 >$at_check_line_file
( $at_traceon; ls bar.output bar.c bar.h ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:67: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  15 ) # 15. output.at:72: Output files: %defines %verbose & .
    at_setup_line='output.at:72'
    $at_verbose "15. output.at:72: testing Output files: %defines %verbose & ...."
    $at_quiet $ECHO_N " 15: output.at:72      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:72: bison  foo.yy"
echo output.at:72 >$at_check_line_file
( $at_traceon; bison  foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:72: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:72: ls foo.output foo.tab.cc foo.tab.hh"
echo output.at:72 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.cc foo.tab.hh ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:72: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  16 ) # 16. output.at:75: Output files: %defines %verbose  & -o foo.c.
    at_setup_line='output.at:75'
    $at_verbose "16. output.at:75: testing Output files: %defines %verbose  & -o foo.c...."
    $at_quiet $ECHO_N " 16: output.at:75      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:75: bison -o foo.c foo.yy"
echo output.at:75 >$at_check_line_file
( $at_traceon; bison -o foo.c foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:75: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:75: ls foo.c foo.h foo.output"
echo output.at:75 >$at_check_line_file
( $at_traceon; ls foo.c foo.h foo.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:75: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  17 ) # 17. output.at:79: Output files:  & --defines=foo.hpp -o foo.c++.
    at_setup_line='output.at:79'
    $at_verbose "17. output.at:79: testing Output files:  & --defines=foo.hpp -o foo.c++...."
    $at_quiet $ECHO_N " 17: output.at:79      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:79: bison --defines=foo.hpp -o foo.c++ foo.yy"
echo output.at:79 >$at_check_line_file
( $at_traceon; bison --defines=foo.hpp -o foo.c++ foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:79: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:79: ls foo.c++ foo.hpp"
echo output.at:79 >$at_check_line_file
( $at_traceon; ls foo.c++ foo.hpp ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:79: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  18 ) # 18. output.at:83: Output files:  & -o foo.c++ --graph=foo.gph.
    at_setup_line='output.at:83'
    $at_verbose "18. output.at:83: testing Output files:  & -o foo.c++ --graph=foo.gph...."
    $at_quiet $ECHO_N " 18: output.at:83      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:83: bison -o foo.c++ --graph=foo.gph foo.yy"
echo output.at:83 >$at_check_line_file
( $at_traceon; bison -o foo.c++ --graph=foo.gph foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:83: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:83: ls foo.c++ foo.gph"
echo output.at:83 >$at_check_line_file
( $at_traceon; ls foo.c++ foo.gph ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:83: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  19 ) # 19. output.at:87: Clashing Output Files
    at_setup_line='output.at:87'
    $at_verbose "19. output.at:87: testing Clashing Output Files..."
    $at_quiet $ECHO_N " 19: output.at:87      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%% foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:94: bison -do foo.x foo.y"
echo output.at:94 >$at_check_line_file
( $at_traceon; bison -do foo.x foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "foo.y:2: fatal error: header and parser would both be named \`foo.x'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "output.at:94: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-3 ) # Banner 3. sets.at:19
    cat <<\_ATEOF

Grammar Sets (Firsts etc.).

_ATEOF
    ;;

  20 ) # 20. sets.at:26: Nullable
    at_setup_line='sets.at:26'
    $at_verbose "20. sets.at:26: testing Nullable..."
    $at_quiet $ECHO_N " 20: sets.at:26        $ECHO_C"
    (
      $at_traceon


# At some point, nullable had been smoking grass, and managed to say:
#
# Entering set_nullable
# NULLABLE
#         'e': yes
#         (null): no
# ...

cat >input.y <<'_ATEOF'
%%
e: 'e' | /* Nothing */;
_ATEOF


$at_traceoff
$at_verbose "sets.at:116: bison --trace input.y"
echo sets.at:116 >$at_check_line_file
( $at_traceon; bison --trace input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "RITEM
  'e'  (rule 1)
  (rule 2)


DERIVES
	e derives
		1: 'e' (rule 1)
		2: (rule 2)


Entering set_nullable
NULLABLE
	e: yes


TC: Input BEGIN
    
   0
  .-.
 0| |
  \`-'
TC: Input END

TC: Output BEGIN
    
   0
  .-.
 0| |
  \`-'
TC: Output END

FIRSTS
	e firsts
		4 (e)


FDERIVES
	e derives
		1: 'e'
		2:


Processing state 0 (reached by \$)
Closure: input


Closure: output
   0: . 'e'  (rule 1)
   2: .  (rule 2)


Entering new_itemsets, state = 0
Entering append_states, state = 0
Entering get_state, state = 0, symbol = 3 ('e')
Entering new_state, state = 0, symbol = 3 ('e')
Exiting get_state => 1
Processing state 1 (reached by 'e')
Closure: input
   1: .  (rule 1)


Closure: output
   1: .  (rule 1)


Entering new_itemsets, state = 1
Entering append_states, state = 1
transpose: input
  0: 

transpose: output
  0: 

" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:116: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  21 ) # 21. sets.at:160: Broken Closure
    at_setup_line='sets.at:160'
    $at_verbose "21. sets.at:160: testing Broken Closure..."
    $at_quiet $ECHO_N " 21: sets.at:160       $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
a: b;
b: c;
c: d;
d: e;
e: f;
f: g;
g: h;
h: 'h';
_ATEOF


$at_traceoff
$at_verbose "sets.at:191: bison --trace input.y 2>&1 |
          sed -n '/^TC: Output BEGIN/,/^TC: Output END/p'"
echo sets.at:191 >$at_check_line_file
( $at_traceon; bison --trace input.y 2>&1 |
          sed -n '/^TC: Output BEGIN/,/^TC: Output END/p' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "TC: Output BEGIN
           
   01234567
  .--------.
 0| 1111111|
 1|  111111|
 2|   11111|
 3|    1111|
 4|     111|
 5|      11|
 6|       1|
 7|        |
  \`--------'
TC: Output END
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:191: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-4 ) # Banner 4. reduce.at:19
    cat <<\_ATEOF

Grammar Reduction.

_ATEOF
    ;;

  22 ) # 22. reduce.at:26: Useless Terminals
    at_setup_line='reduce.at:26'
    $at_verbose "22. reduce.at:26: testing Useless Terminals..."
    $at_quiet $ECHO_N " 22: reduce.at:26      $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output="input.c"

%token useless1
%token useless2
%token useless3
%token useless4
%token useless5
%token useless6
%token useless7
%token useless8
%token useless9

%token useful
%%
exp: useful;
_ATEOF


$at_traceoff
$at_verbose "reduce.at:47: bison input.y"
echo reduce.at:47 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:47: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "reduce.at:60: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:60 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Terminals which are not used:
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:60: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  23 ) # 23. reduce.at:70: Useless Nonterminals
    at_setup_line='reduce.at:70'
    $at_verbose "23. reduce.at:70: testing Useless Nonterminals..."
    $at_quiet $ECHO_N " 23: reduce.at:70      $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output="input.c"

%nterm useless1
%nterm useless2
%nterm useless3
%nterm useless4
%nterm useless5
%nterm useless6
%nterm useless7
%nterm useless8
%nterm useless9

%token useful
%%
exp: useful;
_ATEOF


$at_traceoff
$at_verbose "reduce.at:93: bison input.y"
echo reduce.at:93 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y contains 9 useless nonterminals
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:93: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "reduce.at:106: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:106 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals:
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:106: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  24 ) # 24. reduce.at:116: Useless Rules
    at_setup_line='reduce.at:116'
    $at_verbose "24. reduce.at:116: testing Useless Rules..."
    $at_quiet $ECHO_N " 24: reduce.at:116     $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output="input.c"
%token useful
%%
exp: useful;
useless1: '1';
useless2: '2';
useless3: '3';
useless4: '4';
useless5: '5';
useless6: '6';
useless7: '7';
useless8: '8';
useless9: '9';
_ATEOF


$at_traceoff
$at_verbose "reduce.at:137: bison input.y"
echo reduce.at:137 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y contains 9 useless nonterminals and 9 useless rules
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:137: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "reduce.at:170: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:170 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals:
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
Terminals which are not used:
   '1'
   '2'
   '3'
   '4'
   '5'
   '6'
   '7'
   '8'
   '9'
Useless rules:
#2     useless1: '1';
#3     useless2: '2';
#4     useless3: '3';
#5     useless4: '4';
#6     useless5: '5';
#7     useless6: '6';
#8     useless7: '7';
#9     useless8: '8';
#10    useless9: '9';
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:170: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  25 ) # 25. reduce.at:180: Underivable Rules
    at_setup_line='reduce.at:180'
    $at_verbose "25. reduce.at:180: testing Underivable Rules..."
    $at_quiet $ECHO_N " 25: reduce.at:180     $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output="input.c"
%token useful
%%
exp: useful | underivable;
underivable: indirection;
indirection: underivable;
_ATEOF


$at_traceoff
$at_verbose "reduce.at:194: bison input.y"
echo reduce.at:194 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y contains 2 useless nonterminals and 3 useless rules
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:194: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "reduce.at:204: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:204 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals:
   underivable
   indirection
Useless rules:
#2     exp: underivable;
#3     underivable: indirection;
#4     indirection: underivable;
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:204: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-5 ) # Banner 5. calc.at:19
    cat <<\_ATEOF

Simple Calculator.

_ATEOF
    ;;

  26 ) # 26. calc.at:385: Calculator
    at_setup_line='calc.at:385'
    $at_verbose "26. calc.at:385: testing Calculator ..."
    $at_quiet $ECHO_N " 26: calc.at:385       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>


static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:385: bison calc.y -o calc.c "
echo calc.at:385 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c  ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:385: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:385 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:385: ./calc input"
echo calc.at:385 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:385: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:385 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:385: ./calc input"
echo calc.at:385 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:385: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:385 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:385: cat stderr"
echo calc.at:385 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:385: ./calc input"
echo calc.at:385 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:385: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:385 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:385: cat stderr"
echo calc.at:385 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:385: ./calc input"
echo calc.at:385 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:385: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:385 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:385: cat stderr"
echo calc.at:385 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:385: ./calc input"
echo calc.at:385 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:385: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:385 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:385: cat stderr"
echo calc.at:385 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:385: ./calc input"
echo calc.at:385 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:385: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:385 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:385: cat stderr"
echo calc.at:385 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:385: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  27 ) # 27. calc.at:387: Calculator --defines
    at_setup_line='calc.at:387'
    $at_verbose "27. calc.at:387: testing Calculator --defines..."
    $at_quiet $ECHO_N " 27: calc.at:387       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>


static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:387: bison calc.y -o calc.c --defines"
echo calc.at:387 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c --defines ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:387: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:387 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:387: ./calc input"
echo calc.at:387 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:387: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:387 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:387: ./calc input"
echo calc.at:387 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:387: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:387 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:387: cat stderr"
echo calc.at:387 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:387: ./calc input"
echo calc.at:387 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:387: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:387 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:387: cat stderr"
echo calc.at:387 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:387: ./calc input"
echo calc.at:387 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:387: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:387 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:387: cat stderr"
echo calc.at:387 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:387: ./calc input"
echo calc.at:387 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:387: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:387 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:387: cat stderr"
echo calc.at:387 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:387: ./calc input"
echo calc.at:387 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:387: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:387 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:387: cat stderr"
echo calc.at:387 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:387: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  28 ) # 28. calc.at:388: Calculator --locations
    at_setup_line='calc.at:388'
    $at_verbose "28. calc.at:388: testing Calculator --locations..."
    $at_quiet $ECHO_N " 28: calc.at:388       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>


static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:388: bison calc.y -o calc.c --locations"
echo calc.at:388 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c --locations ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:388: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:388 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:388: ./calc input"
echo calc.at:388 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:388: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:388 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:388: ./calc input"
echo calc.at:388 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:388: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:388 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:388: cat stderr"
echo calc.at:388 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.0:1.1: parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:388: ./calc input"
echo calc.at:388 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:388: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:388 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:388: cat stderr"
echo calc.at:388 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.2:1.3: parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:388: ./calc input"
echo calc.at:388 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:388: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:388 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:388: cat stderr"
echo calc.at:388 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.0:1.1: parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:388: ./calc input"
echo calc.at:388 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:388: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:388 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:388: cat stderr"
echo calc.at:388 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.6:1.7: parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:388: ./calc input"
echo calc.at:388 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:388: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:388 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:388: cat stderr"
echo calc.at:388 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "2.0:2.1: parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  29 ) # 29. calc.at:389: Calculator --name-prefix=calc
    at_setup_line='calc.at:389'
    $at_verbose "29. calc.at:389: testing Calculator --name-prefix=calc..."
    $at_quiet $ECHO_N " 29: calc.at:389       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>


static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:389: bison calc.y -o calc.c --name-prefix=calc"
echo calc.at:389 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c --name-prefix=calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:389: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:389 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:389: ./calc input"
echo calc.at:389 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:389: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:389 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:389: ./calc input"
echo calc.at:389 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:389: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:389 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:389: cat stderr"
echo calc.at:389 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:389: ./calc input"
echo calc.at:389 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:389: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:389 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:389: cat stderr"
echo calc.at:389 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:389: ./calc input"
echo calc.at:389 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:389: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:389 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:389: cat stderr"
echo calc.at:389 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:389: ./calc input"
echo calc.at:389 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:389: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:389 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:389: cat stderr"
echo calc.at:389 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:389: ./calc input"
echo calc.at:389 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:389: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:389 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:389: cat stderr"
echo calc.at:389 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:389: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  30 ) # 30. calc.at:390: Calculator --verbose
    at_setup_line='calc.at:390'
    $at_verbose "30. calc.at:390: testing Calculator --verbose..."
    $at_quiet $ECHO_N " 30: calc.at:390       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>


static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:390: bison calc.y -o calc.c --verbose"
echo calc.at:390 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c --verbose ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:390: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:390 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:390: ./calc input"
echo calc.at:390 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:390: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:390 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:390: ./calc input"
echo calc.at:390 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:390: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:390 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:390: cat stderr"
echo calc.at:390 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:390: ./calc input"
echo calc.at:390 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:390: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:390 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:390: cat stderr"
echo calc.at:390 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:390: ./calc input"
echo calc.at:390 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:390: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:390 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:390: cat stderr"
echo calc.at:390 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:390: ./calc input"
echo calc.at:390 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:390: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:390 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:390: cat stderr"
echo calc.at:390 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:390: ./calc input"
echo calc.at:390 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:390: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:390 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:390: cat stderr"
echo calc.at:390 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:390: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  31 ) # 31. calc.at:391: Calculator --yacc
    at_setup_line='calc.at:391'
    $at_verbose "31. calc.at:391: testing Calculator --yacc..."
    $at_quiet $ECHO_N " 31: calc.at:391       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>


static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:391: bison calc.y -o calc.c --yacc"
echo calc.at:391 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c --yacc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:391: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:391 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:391: ./calc input"
echo calc.at:391 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:391: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:391 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:391: ./calc input"
echo calc.at:391 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:391: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:391 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:391: cat stderr"
echo calc.at:391 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:391: ./calc input"
echo calc.at:391 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:391: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:391 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:391: cat stderr"
echo calc.at:391 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:391: ./calc input"
echo calc.at:391 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:391: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:391 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:391: cat stderr"
echo calc.at:391 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:391: ./calc input"
echo calc.at:391 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:391: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:391 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:391: cat stderr"
echo calc.at:391 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:391: ./calc input"
echo calc.at:391 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:391: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:391 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:391: cat stderr"
echo calc.at:391 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:391: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  32 ) # 32. calc.at:392: Calculator --yyerror-verbose
    at_setup_line='calc.at:392'
    $at_verbose "32. calc.at:392: testing Calculator --yyerror-verbose..."
    $at_quiet $ECHO_N " 32: calc.at:392       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>
#define YYERROR_VERBOSE

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:392: bison calc.y -o calc.c "
echo calc.at:392 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c  ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:392: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:392 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:392: ./calc input"
echo calc.at:392 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:392: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:392 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:392: ./calc input"
echo calc.at:392 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:392: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:392 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:392: cat stderr"
echo calc.at:392 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error, unexpected '+'
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:392: ./calc input"
echo calc.at:392 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:392: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:392 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:392: cat stderr"
echo calc.at:392 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error, unexpected '/', expecting NUM or '-' or '('
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:392: ./calc input"
echo calc.at:392 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:392: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:392 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:392: cat stderr"
echo calc.at:392 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error, unexpected \$undefined.
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:392: ./calc input"
echo calc.at:392 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:392: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:392 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:392: cat stderr"
echo calc.at:392 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error, unexpected '='
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:392: ./calc input"
echo calc.at:392 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:392: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:392 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:392: cat stderr"
echo calc.at:392 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error, unexpected '+'
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:392: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  33 ) # 33. calc.at:394: Calculator --locations --yyerror-verbose
    at_setup_line='calc.at:394'
    $at_verbose "33. calc.at:394: testing Calculator --locations --yyerror-verbose..."
    $at_quiet $ECHO_N " 33: calc.at:394       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>
#define YYERROR_VERBOSE

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:394: bison calc.y -o calc.c --locations "
echo calc.at:394 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c --locations  ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:394: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:394 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:394: ./calc input"
echo calc.at:394 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:394: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:394 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:394: ./calc input"
echo calc.at:394 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:394: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:394 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:394: cat stderr"
echo calc.at:394 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.0:1.1: parse error, unexpected '+'
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:394: ./calc input"
echo calc.at:394 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:394: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:394 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:394: cat stderr"
echo calc.at:394 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.2:1.3: parse error, unexpected '/', expecting NUM or '-' or '('
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:394: ./calc input"
echo calc.at:394 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:394: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:394 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:394: cat stderr"
echo calc.at:394 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.0:1.1: parse error, unexpected \$undefined.
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:394: ./calc input"
echo calc.at:394 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:394: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:394 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:394: cat stderr"
echo calc.at:394 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.6:1.7: parse error, unexpected '='
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:394: ./calc input"
echo calc.at:394 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:394: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:394 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:394: cat stderr"
echo calc.at:394 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "2.0:2.1: parse error, unexpected '+'
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:394: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  34 ) # 34. calc.at:396: Calculator --defines --locations --name-prefix=calc --verbose --yacc --yyerror-verbose
    at_setup_line='calc.at:396'
    $at_verbose "34. calc.at:396: testing Calculator --defines --locations --name-prefix=calc --verbose --yacc --yyerror-verbose..."
    $at_quiet $ECHO_N " 34: calc.at:396       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>
#define YYERROR_VERBOSE

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:396: bison calc.y -o calc.c --defines --locations --name-prefix=calc --verbose --yacc "
echo calc.at:396 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c --defines --locations --name-prefix=calc --verbose --yacc  ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:396: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:396 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:396: ./calc input"
echo calc.at:396 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:396: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:396 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:396: ./calc input"
echo calc.at:396 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:396: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:396 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:396: cat stderr"
echo calc.at:396 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.0:1.1: parse error, unexpected '+'
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:396: ./calc input"
echo calc.at:396 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:396: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:396 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:396: cat stderr"
echo calc.at:396 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.2:1.3: parse error, unexpected '/', expecting NUM or '-' or '('
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:396: ./calc input"
echo calc.at:396 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:396: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:396 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:396: cat stderr"
echo calc.at:396 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.0:1.1: parse error, unexpected \$undefined.
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:396: ./calc input"
echo calc.at:396 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:396: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:396 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:396: cat stderr"
echo calc.at:396 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.6:1.7: parse error, unexpected '='
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:396: ./calc input"
echo calc.at:396 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:396: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:396 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:396: cat stderr"
echo calc.at:396 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "2.0:2.1: parse error, unexpected '+'
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  35 ) # 35. calc.at:398: Calculator --debug
    at_setup_line='calc.at:398'
    $at_verbose "35. calc.at:398: testing Calculator --debug..."
    $at_quiet $ECHO_N " 35: calc.at:398       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>


static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:398: bison calc.y -o calc.c --debug"
echo calc.at:398 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c --debug ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:398: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:398 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:398: ./calc input"
echo calc.at:398 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:398: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:398 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "491
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:398: ./calc input"
echo calc.at:398 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:398: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:398 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "8
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:398: cat stderr"
echo calc.at:398 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:398: ./calc input"
echo calc.at:398 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:398: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:398 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "17
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:398: cat stderr"
echo calc.at:398 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:398: ./calc input"
echo calc.at:398 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:398: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:398 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "8
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:398: cat stderr"
echo calc.at:398 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:398: ./calc input"
echo calc.at:398 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:398: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:398 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "23
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:398: cat stderr"
echo calc.at:398 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:398: ./calc input"
echo calc.at:398 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:398: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:398 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "16
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:398: cat stderr"
echo calc.at:398 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "parse error
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:398: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  36 ) # 36. calc.at:399: Calculator --debug --defines --locations --name-prefix=calc --verbose --yacc --yyerror-verbose
    at_setup_line='calc.at:399'
    $at_verbose "36. calc.at:399: testing Calculator --debug --defines --locations --name-prefix=calc --verbose --yacc --yyerror-verbose..."
    $at_quiet $ECHO_N " 36: calc.at:399       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>
#define YYERROR_VERBOSE

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);
%}

/* Bison Declarations */
%token CALC_EOF 0
%token NUM

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  /* empty string */
| input line
;

line:
  '\n'
| exp '\n'
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       printf ("calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d:%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}

static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 0;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc.last_column--;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 0;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:399: bison calc.y -o calc.c --debug --defines --locations --name-prefix=calc --verbose --yacc "
echo calc.at:399 >$at_check_line_file
( $at_traceon; bison calc.y -o calc.c --debug --defines --locations --name-prefix=calc --verbose --yacc  ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:399: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:399 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:399: ./calc input"
echo calc.at:399 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon
$at_traceoff
$at_verbose "calc.at:399: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:399 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "491
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:399: ./calc input"
echo calc.at:399 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:399: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:399 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "8
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:399: cat stderr"
echo calc.at:399 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.0:1.1: parse error, unexpected '+'
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1//2
_ATEOF


$at_traceoff
$at_verbose "calc.at:399: ./calc input"
echo calc.at:399 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:399: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:399 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "17
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:399: cat stderr"
echo calc.at:399 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.2:1.3: parse error, unexpected '/', expecting NUM or '-' or '('
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
error
_ATEOF


$at_traceoff
$at_verbose "calc.at:399: ./calc input"
echo calc.at:399 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:399: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:399 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "8
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:399: cat stderr"
echo calc.at:399 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.0:1.1: parse error, unexpected \$undefined.
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF


$at_traceoff
$at_verbose "calc.at:399: ./calc input"
echo calc.at:399 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:399: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:399 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "23
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:399: cat stderr"
echo calc.at:399 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "1.6:1.7: parse error, unexpected '='
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



cat >input <<'_ATEOF'

+1
_ATEOF


$at_traceoff
$at_verbose "calc.at:399: ./calc input"
echo calc.at:399 >$at_check_line_file
( $at_traceon; ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



$at_traceoff
$at_verbose "calc.at:399: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:399 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "16
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


egrep -v '^((Start|Enter|Read|Reduc|Shift)ing|state|Error:) ' stderr >at-stderr
mv at-stderr stderr

$at_traceoff
$at_verbose "calc.at:399: cat stderr"
echo calc.at:399 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "2.0:2.1: parse error, unexpected '+'
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:399: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-6 ) # Banner 6. torture.at:19
    cat <<\_ATEOF

Torture Tests.

_ATEOF
    ;;

  37 ) # 37. torture.at:83: Exploding the Stack Size with Alloca
    at_setup_line='torture.at:83'
    $at_verbose "37. torture.at:83: testing Exploding the Stack Size with Alloca..."
    $at_quiet $ECHO_N " 37: torture.at:83     $ECHO_C"
    (
      $at_traceon


# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

  static int yylex (void);
  static void yyerror (const char *msg);
#define YYERROR_VERBOSE 1
#define YYPRINT(File, Type, Value)                   \
  fprintf (File, " (%d, stack size = %d, max = %d)", \
           Value, yyssp - yyss + 1, yystacksize);
%}
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

/* There are YYLVAL_MAX of WAIT_FOR_EOFs. */
unsigned int yylval_max;

static int
yylex (void)
{
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  assert (argc == 2);
  yylval = atoi (argv[1]);
  yydebug = 1;
  return yyparse ();
}
_ATEOF

$at_traceoff
$at_verbose "torture.at:85: bison input.y -o input.c"
echo torture.at:85 >$at_check_line_file
( $at_traceon; bison input.y -o input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:85: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:85: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo torture.at:85 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:85: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Below the limit of 200.
$at_traceoff
$at_verbose "torture.at:88: ./input 20"
echo torture.at:88 >$at_check_line_file
( $at_traceon; ./input 20 ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:88: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# Two enlargements: 2 * 2 * 200.
$at_traceoff
$at_verbose "torture.at:90: ./input 900"
echo torture.at:90 >$at_check_line_file
( $at_traceon; ./input 900 ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:90: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the last possible).
$at_traceoff
$at_verbose "torture.at:93: ./input 10000"
echo torture.at:93 >$at_check_line_file
( $at_traceon; ./input 10000 ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "torture.at:93: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  38 ) # 38. torture.at:104: Exploding the Stack Size with Malloc
    at_setup_line='torture.at:104'
    $at_verbose "38. torture.at:104: testing Exploding the Stack Size with Malloc..."
    $at_quiet $ECHO_N " 38: torture.at:104    $ECHO_C"
    (
      $at_traceon


# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#define YYSTACK_USE_ALLOCA 0
  static int yylex (void);
  static void yyerror (const char *msg);
#define YYERROR_VERBOSE 1
#define YYPRINT(File, Type, Value)                   \
  fprintf (File, " (%d, stack size = %d, max = %d)", \
           Value, yyssp - yyss + 1, yystacksize);
%}
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

/* There are YYLVAL_MAX of WAIT_FOR_EOFs. */
unsigned int yylval_max;

static int
yylex (void)
{
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  assert (argc == 2);
  yylval = atoi (argv[1]);
  yydebug = 1;
  return yyparse ();
}
_ATEOF

$at_traceoff
$at_verbose "torture.at:106: bison input.y -o input.c"
echo torture.at:106 >$at_check_line_file
( $at_traceon; bison input.y -o input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:106: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:106: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo torture.at:106 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:106: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Below the limit of 200.
$at_traceoff
$at_verbose "torture.at:109: ./input 20"
echo torture.at:109 >$at_check_line_file
( $at_traceon; ./input 20 ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:109: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# Two enlargements: 2 * 2 * 200.
$at_traceoff
$at_verbose "torture.at:111: ./input 900"
echo torture.at:111 >$at_check_line_file
( $at_traceon; ./input 900 ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:111: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the possible).
$at_traceoff
$at_verbose "torture.at:114: ./input 10000"
echo torture.at:114 >$at_check_line_file
( $at_traceon; ./input 10000 ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "torture.at:114: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  39 ) # 39. torture.at:123: GNU AWK Grammar
    at_setup_line='torture.at:123'
    $at_verbose "39. torture.at:123: testing GNU AWK Grammar..."
    $at_quiet $ECHO_N " 39: torture.at:123    $ECHO_C"
    (
      $at_traceon


# We have been careful to strip all the actions excepts the
# mid-rule actions.  We rely on %expect to check that there are
# indeed 65 SR conflicts.
#
# Bison was once wrong, due to an incorrect computation of nullable.
# It reported 485 SR conflicts!

cat >input.y <<'_ATEOF'
%expect 65

%token FUNC_CALL NAME REGEXP
%token ERROR
%token YNUMBER YSTRING
%token RELOP APPEND_OP
%token ASSIGNOP MATCHOP NEWLINE CONCAT_OP
%token LEX_BEGIN LEX_END LEX_IF LEX_ELSE LEX_RETURN LEX_DELETE
%token LEX_WHILE LEX_DO LEX_FOR LEX_BREAK LEX_CONTINUE
%token LEX_PRINT LEX_PRINTF LEX_NEXT LEX_EXIT LEX_FUNCTION
%token LEX_GETLINE LEX_NEXTFILE
%token LEX_IN
%token LEX_AND LEX_OR INCREMENT DECREMENT
%token LEX_BUILTIN LEX_LENGTH

/* Lowest to highest */
%right ASSIGNOP
%right '?' ':'
%left LEX_OR
%left LEX_AND
%left LEX_GETLINE
%nonassoc LEX_IN
%left FUNC_CALL LEX_BUILTIN LEX_LENGTH
%nonassoc ','
%nonassoc MATCHOP
%nonassoc RELOP '<' '>' '|' APPEND_OP TWOWAYIO
%left CONCAT_OP
%left YSTRING YNUMBER
%left '+' '-'
%left '*' '/' '%'
%right '!' UNARY
%right '^'
%left INCREMENT DECREMENT
%left '$'
%left '(' ')'
%%

start
	: opt_nls program opt_nls
	;

program
	: rule
	| program rule
	| error
	| program error
	| /* empty */
	;

rule
	: LEX_BEGIN {} action
	| LEX_END {}   action
	| LEX_BEGIN statement_term
	| LEX_END statement_term
	| pattern action
	| action
	| pattern statement_term
	| function_prologue function_body
	;

func_name
	: NAME
	| FUNC_CALL
	| lex_builtin
	;

lex_builtin
	: LEX_BUILTIN
	| LEX_LENGTH
	;

function_prologue
	: LEX_FUNCTION {} func_name '(' opt_param_list r_paren opt_nls
	;

function_body
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;


pattern
	: exp
	| exp ',' exp
	;

regexp
	/*
	 * In this rule, want_regexp tells yylex that the next thing
	 * is a regexp so it should read up to the closing slash.
	 */
	: '/' {} REGEXP '/'
	;

action
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

statements
	: statement
	| statements statement
	| error
	| statements error
	;

statement_term
	: nls
	| semi opt_nls
	;

statement
	: semi opt_nls
	| l_brace r_brace
	| l_brace statements r_brace
	| if_statement
	| LEX_WHILE '(' exp r_paren opt_nls statement
	| LEX_DO opt_nls statement LEX_WHILE '(' exp r_paren opt_nls
	| LEX_FOR '(' NAME LEX_IN NAME r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls exp semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_BREAK statement_term
	| LEX_CONTINUE statement_term
	| print '(' expression_list r_paren output_redir statement_term
	| print opt_rexpression_list output_redir statement_term
	| LEX_NEXT statement_term
	| LEX_NEXTFILE statement_term
	| LEX_EXIT opt_exp statement_term
	| LEX_RETURN {} opt_exp statement_term
	| LEX_DELETE NAME '[' expression_list ']' statement_term
	| LEX_DELETE NAME  statement_term
	| exp statement_term
	;

print
	: LEX_PRINT
	| LEX_PRINTF
	;

if_statement
	: LEX_IF '(' exp r_paren opt_nls statement
	| LEX_IF '(' exp r_paren opt_nls statement
	     LEX_ELSE opt_nls statement
	;

nls
	: NEWLINE
	| nls NEWLINE
	;

opt_nls
	: /* empty */
	| nls
	;

input_redir
	: /* empty */
	| '<' simp_exp
	;

output_redir
	: /* empty */
	| '>' exp
	| APPEND_OP exp
	| '|' exp
	| TWOWAYIO exp
	;

opt_param_list
	: /* empty */
	| param_list
	;

param_list
	: NAME
	| param_list comma NAME
	| error
	| param_list error
	| param_list comma error
	;

/* optional expression, as in for loop */
opt_exp
	: /* empty */
	| exp
	;

opt_rexpression_list
	: /* empty */
	| rexpression_list
	;

rexpression_list
	: rexp
	| rexpression_list comma rexp
	| error
	| rexpression_list error
	| rexpression_list error rexp
	| rexpression_list comma error
	;

opt_expression_list
	: /* empty */
	| expression_list
	;

expression_list
	: exp
	| expression_list comma exp
	| error
	| expression_list error
	| expression_list error exp
	| expression_list comma error
	;

/* Expressions, not including the comma operator.  */
exp	: variable ASSIGNOP {} exp
	| '(' expression_list r_paren LEX_IN NAME
	| exp '|' LEX_GETLINE opt_variable
	| exp TWOWAYIO LEX_GETLINE opt_variable
	| LEX_GETLINE opt_variable input_redir
	| exp LEX_AND exp
	| exp LEX_OR exp
	| exp MATCHOP exp
	| regexp
	| '!' regexp %prec UNARY
	| exp LEX_IN NAME
	| exp RELOP exp
	| exp '<' exp
	| exp '>' exp
	| exp '?' exp ':' exp
	| simp_exp
	| exp simp_exp %prec CONCAT_OP
	;

rexp
	: variable ASSIGNOP {} rexp
	| rexp LEX_AND rexp
	| rexp LEX_OR rexp
	| LEX_GETLINE opt_variable input_redir
	| regexp
	| '!' regexp %prec UNARY
	| rexp MATCHOP rexp
	| rexp LEX_IN NAME
	| rexp RELOP rexp
	| rexp '?' rexp ':' rexp
	| simp_exp
	| rexp simp_exp %prec CONCAT_OP
	;

simp_exp
	: non_post_simp_exp
	/* Binary operators in order of decreasing precedence.  */
	| simp_exp '^' simp_exp
	| simp_exp '*' simp_exp
	| simp_exp '/' simp_exp
	| simp_exp '%' simp_exp
	| simp_exp '+' simp_exp
	| simp_exp '-' simp_exp
	| variable INCREMENT
	| variable DECREMENT
	;

non_post_simp_exp
	: '!' simp_exp %prec UNARY
	| '(' exp r_paren
	| LEX_BUILTIN
	  '(' opt_expression_list r_paren
	| LEX_LENGTH '(' opt_expression_list r_paren
	| LEX_LENGTH
	| FUNC_CALL '(' opt_expression_list r_paren
	| variable
	| INCREMENT variable
	| DECREMENT variable
	| YNUMBER
	| YSTRING
	| '-' simp_exp    %prec UNARY
	| '+' simp_exp    %prec UNARY
	;

opt_variable
	: /* empty */
	| variable
	;

variable
	: NAME
	| NAME '[' expression_list ']'
	| '$' non_post_simp_exp
	;

l_brace
	: '{' opt_nls
	;

r_brace
	: '}' opt_nls
	;

r_paren
	: ')'
	;

opt_semi
	: /* empty */
	| semi
	;

semi
	: ';'
	;

comma	: ',' opt_nls
	;

%%
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
$at_traceoff
$at_verbose "torture.at:454: bison --verbose --defines input.y"
echo torture.at:454 >$at_check_line_file
( $at_traceon; bison --verbose --defines input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  40 ) # 40. torture.at:463: GNU Cim Grammar
    at_setup_line='torture.at:463'
    $at_verbose "40. torture.at:463: testing GNU Cim Grammar..."
    $at_quiet $ECHO_N " 40: torture.at:463    $ECHO_C"
    (
      $at_traceon


# GNU Cim, the GNU Simula 87 Compiler.

# Bison was once wrong, due to an incorrect computation of the RR conflicts.
# It reported 80 SR && 99 RR conflicts instead of 78/10!!!

cat >input.y <<'_ATEOF'
%union {
	long token;
	long ival;
        long arrdim;
	double rval;
	char *ident;
	char *tval;
	char stat_decl;
       }

%token
        HACTIVATE HAFTER /*HAND*/ HARRAY HAT
        HBEFORE HBEGIN HBOOLEAN
        HCHARACTER HCLASS /*HCOMMENT*/ HCONC
        HDELAY HDO
        HELSE HEND HEQ /*HEQV*/ HEXTERNAL
        HFOR
        HGE HGO HGOTO HGT
        HHIDDEN
        HIF /*HIMP*/ HIN HINNER HINSPECT HINTEGER HIS
        HLABEL HLE HLONG HLT
        HNAME HNE HNEW HNONE /*HNOT*/ HNOTEXT
        /*HOR*/ HOTHERWISE
        HPRIOR HPROCEDURE HPROTECTED
        HQUA
        HREACTIVATE HREAL HREF
        HSHORT HSTEP HSWITCH
        HTEXT HTHEN HTHIS HTO
        HUNTIL
        HVALUE HVAR HVIRTUAL
        HWHEN HWHILE

        HASSIGNVALUE HASSIGNREF
        /*HDOT*/ HPAREXPSEPARATOR HLABELSEPARATOR HSTATEMENTSEPARATOR
        HBEGPAR HENDPAR
        HEQR HNER
        HADD HSUB HMUL HDIV HINTDIV HEXP
  	HDOTDOTDOT

%token <ident> HIDENTIFIER
%token <ival> HBOOLEANKONST HINTEGERKONST HCHARACTERKONST
%token <rval> HREALKONST
%token <tval> HTEXTKONST

%type <tval> EXT_IDENT
%type <stat_decl> DECLSTATEMENT MODULSTATEMENT MBEE_DECLSTMS MBEE_DECLSTMSU
%type <stat_decl> MODULS
%type <ident> EXPRESSION_SIMP MBEE_ARG_R_PT
%type <arrdim> BAUND_PAIR_LIST

%right <token> HASSIGN
%left   HORELSE
%left   HANDTHEN
%left   HEQV
%left   HIMP
%left   HOR
%left   HAND

%left   HNOT

%left <token> HVALRELOPERATOR HREFRELOPERATOR HOBJRELOPERATOR

%left	HCONC

%left <token> HTERMOPERATOR
%left <token> UNEAR
%left <token> HFACTOROPERATOR
%left         HPRIMARYOPERATOR

%left   HQUA

%left   HDOT

%start  MAIN_MODULE
%%
/* GRAMATIKK FOR PROGRAM MODULES */
MAIN_MODULE     :       {	  categ=CLOCAL; mout(MBLOCK);
                                  beginBlock(KBLOKK);separat_comp=FALSE;}
			MODULS	{ endBlock(NULL,CCNO);   mout(MENDBLOCK);}
  		|	error HSTATEMENTSEPARATOR MBEE_DECLSTMS
		;
EXT_DECLARATION	:	HEXTERNAL
			MBEE_TYPE
			HPROCEDURE
				{ MBEENEWBLOCK();
				  kind=KPROC;}
			EXT_LIST
		|
			HEXTERNAL
			HIDENTIFIER
			HPROCEDURE
				{ MBEENEWBLOCK();
				  type=TNOTY;
				  kind=KPROC;
				  if($2==Ckind)categ=CCPROC;else
				  yerror (1);
                                  ysensitive=sensitive;
                                  sensitive=ON;}
			HIDENTIFIER { $<ident>$=$5;
                                  sensitive=ysensitive;}
			EXTERNAL_KIND_ITEM
			        { categ=CLOCAL;}
		|	HEXTERNAL
			HCLASS
				{ MBEENEWBLOCK();
				  kind=KCLASS;}
			EXT_LIST

		;
EXTERNAL_KIND_ITEM:	EXT_IDENT
			HOBJRELOPERATOR
				{ if($2!=HIS)yerror (2);}
		        MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{         regDecl($6, type, KPROC, CCPROC);
                                          beginBlock(kind);}
                        HEADING EMPTY_BLOCK
				{ categ=CLOCAL;
				  endBlock($1==NULL?$<ident>0:tag($1),CCCPROC);}
/*		|
			EXT_IDENT
				{ if($1!=NULL)yerror (3);
				  regDecl($0, type, kind, categ);}
			MBEE_REST_EXT_LIST
				{ endBlock(NULL,CCNO);}
		;
MBEE_REST_EXT_LIST:	/* EMPTY
		|	HPAREXPSEPARATOR EXT_KIND_LIST
		;
EXT_KIND_LIST	:	EXT_KIND_ITEM
		|	EXT_KIND_LIST HPAREXPSEPARATOR EXT_KIND_ITEM
		;
EXT_KIND_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{ if($2!=NULL)yerror (3);
				  regDecl($1, type, kind, categ);}*/
		;
EMPTY_BLOCK	:	/*EMPT*/
		|	HBEGIN HEND
		;
EXT_LIST	:	EXT_ITEM
		|	EXT_LIST HPAREXPSEPARATOR EXT_ITEM
		;
EXT_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{ lesinn_external_spec($1,$2, kind);}
		;
EXT_IDENT	:	/* EMPTY */ { $$=NULL;}
		|	HVALRELOPERATOR { if($1!=HEQ)yerror (9);
                                          external=TRUE;}
			HTEXTKONST { $$=$3;external=FALSE;}
		;
/* GRAMATIKK FOR TYPER */
NO_TYPE         :       /*EMPT*/        { type=TNOTY;}
                ;
MBEE_TYPE       :       NO_TYPE
                |       TYPE
                ;
TYPE            :       HREF HBEGPAR
                        HIDENTIFIER
                                { prefquantident=$3;
                                          type=TREF;}
                        HENDPAR
                |       HTEXT           { type=TTEXT;}
                |       HBOOLEAN        { type=TBOOL;}
                |       HCHARACTER      { type=TCHAR;}
                |       HSHORT HINTEGER { type=TSHORT;}
                |       HINTEGER        { type=TINTG;}
                |       HREAL           { type=TREAL;}
                |       HLONG HREAL     { type=TLONG;}
                ;

/* GRAMATIKK FOR DEL AV SETNINGER */
MBEE_ELSE_PART  :       /*EMPT*/
/*		|	HELSE
			HIF
                        EXPRESSION
                        HTHEN   { 		  mout(MELSE);
						  mout(MIF);
                                  OBSBLOCK();}
                        BLOCK   { MBEEENDBLOCK();}
                        MBEE_ELSE_PART          { mout(MENDIF);}*/
                |       HELSE   { OBSBLOCK();     mout(MELSE);}
                        BLOCK   { MBEEENDBLOCK();}
                ;
FOR_LIST        :       FOR_LIST_ELEMENT        { mout(MENDSEP);
                                                  mout(MLISTSEP);}
                |       FOR_LIST_ELEMENT
                        HPAREXPSEPARATOR
                        FOR_LIST                { mout(MLISTSEP);}
                ;
FOR_LIST_ELEMENT:       EXPRESSION
                        MBEE_F_L_EL_R_PT
                ;
MBEE_F_L_EL_R_PT:       /*EMPT*/
                |       HWHILE
                        EXPRESSION              { mout(MFORWHILE);}
                |       HSTEP
                        EXPRESSION
                        HUNTIL
                        EXPRESSION              { mout(MUNTIL);
                                                  mout(MSTEP);}
                ;
GOTO            :       HGO
                        HTO
                |       HGOTO
                ;
CONN_STATE_R_PT :       WHEN_CLAUSE_LIST
                |       HDO   {   beginBlock(KCON);   mout(MDO);
                              OBSBLOCK(); }
                        BLOCK {   endBlock(NULL,CCNO);
                                  MBEEENDBLOCK();  mout(MENDDO);}
                ;
WHEN_CLAUSE_LIST:       HWHEN
                        HIDENTIFIER
                        HDO    {   beginBlock(KCON);  mout(MIDENTIFIER);
                                   OBSBLOCK();     moutId($2);
				   		   mout(MWHEN);}
                        BLOCK  {   endBlock(NULL,CCNO);
                              MBEEENDBLOCK(); mout(MENDWHEN);}
                |       WHEN_CLAUSE_LIST
                        HWHEN
                        HIDENTIFIER
                        HDO    { beginBlock(KCON);	   mout(MIDENTIFIER);
                                 OBSBLOCK();       moutId($3);
				 		   mout(MWHEN);}
                        BLOCK  { endBlock(NULL,CCNO);
                              MBEEENDBLOCK();    mout(MENDWHEN);}
                ;
MBEE_OTWI_CLAUS :       /*EMPT*/
                |       HOTHERWISE {OBSBLOCK();    mout(MOTHERWISE);}

                        BLOCK      {MBEEENDBLOCK();mout(MENDOTHERWISE);}
                ;
ACTIVATOR	:	HACTIVATE		{ mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		|	HREACTIVATE		{ mout(MBOOLEANKONST);
						  moutIval(TRUE);}
		;
SCHEDULE	:	/*EMPT*/		{ mout(MCHARACTERKONST);
						  moutIval(DIRECT);
						  mout(MINTEGERKONST);
						  moutIval(0);
						  mout(MNONE);
						  mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		|	ATDELAY EXPRESSION	{ mout(MNONE);}
			PRIOR
		|	BEFOREAFTER		{ mout(MINTEGERKONST);
						  moutIval(0);}
			EXPRESSION		{ mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		;
ATDELAY		:	HAT			{ mout(MCHARACTERKONST);
						  moutIval(AT);}
		|	HDELAY			{ mout(MCHARACTERKONST);
						  moutIval(DELAYS);}
		;
BEFOREAFTER	:	HBEFORE			{ mout(MCHARACTERKONST);
						  moutIval(BEFORE);}
		|	HAFTER			{ mout(MCHARACTERKONST);
						  moutIval(AFTER);}
		;
PRIOR		:	/*EMPT*/		{ mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		|	HPRIOR			{ mout(MBOOLEANKONST);
						  moutIval(TRUE);}
		;
/* GRAMATIKK FOR SETNINGER OG DEKLARASJONER */
MODULSTATEMENT  :       HWHILE
                        EXPRESSION
                        HDO     { STOPOBSBLOCK(); mout(MWHILE);
                                  OBSBLOCK();}
                        BLOCK   { MBEEENDBLOCK(); mout(MENDWHILE);
					  	          $$=STATEMENT;}
	    	|       HIF
                        EXPRESSION
                        HTHEN   { STOPOBSBLOCK(); mout(MIF);
                                  OBSBLOCK();}
                        BLOCK   { MBEEENDBLOCK();}
                        MBEE_ELSE_PART          { mout(MENDIF);
							  $$=STATEMENT;}
		|       HFOR
                        HIDENTIFIER
                        HASSIGN { STOPOBSBLOCK(); mout(MIDENTIFIER);
                                                  moutId($2);}
                        FOR_LIST
                        HDO     { beginBlock(KFOR);
                        if($3==HASSIGNVALUE)      mout(MFOR);
                                        else      mout(MFORR);
                                  OBSBLOCK();     mout(MFORDO);}
                        BLOCK   { MBEEENDBLOCK();
                                  endBlock(NULL,CCNO); mout(MENDFOR);
							  $$=STATEMENT;}
		|       GOTO
                        EXPRESSION              { mout(MGOTO);
                                  STOPOBSBLOCK();	  $$=STATEMENT;}
		|       HINSPECT
                        EXPRESSION              { mout(MINSPECT);
                                  STOPOBSBLOCK();
                                  beginBlock(KINSP);}
                        CONN_STATE_R_PT
                                { endBlock(NULL,CCNO);}
                        MBEE_OTWI_CLAUS         { mout(MENDINSPECT);
							  $$=STATEMENT;}
		|       HINNER  { STOPOBSBLOCK(); mout(MINNER);
                                  regInner();		  $$=STATEMENT;}
                |       HIDENTIFIER
                        HLABELSEPARATOR
                                { STOPOBSBLOCK();
                                  regDecl($1, TLABEL, KSIMPLE, categ);    mout(MLABEL);
                                                  moutId($1);
                                                  mout(MENDLABEL);}
                        DECLSTATEMENT   { if($4<=DECLARATION)
                                            { yerror (27);
                                              $$=DECLARATION;}
                                          else $$=$4;}
                |       EXPRESSION_SIMP
                        HBEGIN
                                { $<ident>$=$1; }
			IMPORT_SPEC_MODULE
				{ mout(MPRBLOCK);
				  prefquantident=$1;
                                  beginBlock(KPRBLK);}
                        MBEE_DECLSTMS
                        HEND    { endBlock(NULL,CCNO); mout(MENDPRBLOCK);
                                                          $$=STATEMENT;}
		|	EXPRESSION_SIMP HBEGIN error HSTATEMENTSEPARATOR
                        MBEE_DECLSTMS HEND              { $$=STATEMENT;
			         endBlock(NULL,CCNO); mout(MENDPRBLOCK);}
		|	EXPRESSION_SIMP HBEGIN error HEND
						        { $$=STATEMENT;
			         endBlock(NULL,CCNO); mout(MENDPRBLOCK);}

                |       EXPRESSION_SIMP
                                { STOPOBSBLOCK();         $$=STATEMENT;
                                                  mout(MENDASSIGN);}
		|	ACTIVATOR EXPRESSION SCHEDULE
						{      	  $$=STATEMENT;
						  mout(MENDSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENT);
						  moutId(activateid);
						  mout(MENDASSIGN);}
                |       HBEGIN
                                { STOPOBSBLOCK();
                                  OBSBLOCK();}
                        MBEE_DECLSTMS
                        HEND    { MBEEENDBLOCK();         $$=STATEMENT;}
		|       MBEE_TYPE HPROCEDURE
                        HIDENTIFIER
                                { MBEENEWBLOCK(); mout(MPROCEDURE);
                                          regDecl($3, type, KPROC, categ);
                                          beginBlock(KPROC);}
                        HEADING BLOCK   { endBlock(NULL,CCNO); $$=DECLARATION;
                                                  mout(MENDPROCEDURE);}
		|       HIDENTIFIER
			HCLASS
                        NO_TYPE
				{ $<ident>$=$1; }
			IMPORT_SPEC_MODULE
                        HIDENTIFIER
				{ prefquantident=$1;
				  mout(MCLASS);
                                          regDecl($6, TNOTY, KCLASS, categ);
                                          beginBlock(KCLASS);}
                        HEADING
                        BLOCK           { endBlock(NULL,CCNO); $$=DECLARATION;
                                                  mout(MENDCLASS);}
                |       HCLASS
                        NO_TYPE
                        HIDENTIFIER
                                { prefquantident=0;
                                  MBEENEWBLOCK(); mout(MCLASS);
                                          regDecl($3, TNOTY, KCLASS, categ);
                                          beginBlock(KCLASS);}
                        HEADING
                        BLOCK           { endBlock(NULL,CCNO); $$=DECLARATION;
                                                  mout(MENDCLASS);}
                |       EXT_DECLARATION			{ $$=EXTDECLARATION;}
		|       /*EMPT*/{ STOPOBSBLOCK();	  $$=EMPTYSTATEMENT;}
                ;
IMPORT_SPEC_MODULE:		{ MBEENEWBLOCK();
                                  kind=KCLASS;
				  if($<ident>0==simsetident &&
				     findDecl(simsetident,cblock,FALSE)==NULL)
				    lesinn_external_spec(simsetident,
					SIMSETATRFILE, kind);
				  if($<ident>0==simulationident && findDecl(
				    simulationident,cblock,FALSE)==NULL)
				    lesinn_external_spec(simulationident,
					SIMULATIONATRFILE, kind);
				  if(($<ident>0==fileident && findDecl(
				      fileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==outfileident && findDecl(
				      outfileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==infileident && findDecl(
				      infileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==directfileident && findDecl(
				      directfileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==printfileident && findDecl(
				      printfileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==bytefileident && findDecl(
				      bytefileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==inbytefileident && findDecl(
				      inbytefileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==outbytefileident && findDecl(
				      outbytefileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==directbytefileident && findDecl(
				      directbytefileident,cblock,FALSE)==NULL))
				    lesinn_external_spec(fileident,
					FILEATRFILE, kind);}
		;
DECLSTATEMENT	:	MODULSTATEMENT
		|       TYPE
                        HIDENTIFIER
			MBEE_CONSTANT
                        HPAREXPSEPARATOR
                                { MBEENEWBLOCK();
                                          kind=KSIMPLE;
                                          regDecl($2, type, KSIMPLE, categ);
					  categ=CLOCAL;}
                        IDENTIFIER_LISTC                { $$=DECLARATION;}
                |       TYPE
                        HIDENTIFIER
			MBEE_CONSTANT
                                { MBEENEWBLOCK();
                                          regDecl($2, type, KSIMPLE, categ);
					  categ=CLOCAL;	  $$=DECLARATION;}
                |       MBEE_TYPE
                        HARRAY  { MBEENEWBLOCK();
                                          kind=KARRAY;}
                        ARR_SEGMENT_LIST                { $$=DECLARATION;}
                |       HSWITCH
                        HIDENTIFIER
                        HASSIGN { MBEENEWBLOCK(); mout(MIDENTIFIER);
                                                  moutId($2);
                                          regDecl($2, TLABEL, KARRAY, categ);}
                        SWITCH_LIST                     { $$=DECLARATION;
                                                   mout(MSWITCH);
                                                   mout(MENDSWITCH);}
                ;
BLOCK           :       DECLSTATEMENT   { if($1<=DECLARATION)yerror (29);}
                |       HBEGIN MBEE_DECLSTMS HEND
		|	HBEGIN error HSTATEMENTSEPARATOR MBEE_DECLSTMS HEND
		|	HBEGIN error HEND
		;
MBEE_DECLSTMS   :       MBEE_DECLSTMSU  { if($1<=DECLARATION)yerror (28);
					  $$=$1;}
                ;
MBEE_DECLSTMSU  :       DECLSTATEMENT   { $$=$1;}
                |       MBEE_DECLSTMSU
                        HSTATEMENTSEPARATOR
                        DECLSTATEMENT   { if($1>=STATEMENT && $3<=DECLARATION)
                                            yerror (26);
                                          $$=$3;}
                ;
MODULS		:	MODULSTATEMENT	{ if($1==DECLARATION)
					  {separat_comp=TRUE;gettimestamp();}
                                          $$=$1;}
  		|	MODULS HSTATEMENTSEPARATOR MODULSTATEMENT
					{ if($1>=STATEMENT && $3<=DECLARATION)
                                            yerror (26);else
       					  if($1>=STATEMENT
					     && $3!=EMPTYSTATEMENT)yerror (25);
                                          if(separat_comp && $3==STATEMENT)
                                             yerror (25);
                                          if($3==DECLARATION && !separat_comp)
					  {separat_comp=TRUE;gettimestamp();}
					  $$=$3;}
		;
/* GRAMATIKK FOR DEL AV DEKLARASJONER */
ARR_SEGMENT_LIST:       ARR_SEGMENT
                |       ARR_SEGMENT_LIST
                        HPAREXPSEPARATOR
                        ARR_SEGMENT
                ;
ARR_SEGMENT	:       ARRAY_SEGMENT
                        HBEGPAR
                        BAUND_PAIR_LIST HENDPAR { mout(MARRAY);
                                                  mout(MENDARRAY);
                                                  setArrayDim($3);}
                ;
ARRAY_SEGMENT   :       ARRAY_SEGMENT_EL        { mout(MENDSEP);
                                                  mout(MARRAYSEP);}

                |       ARRAY_SEGMENT_EL
                        HPAREXPSEPARATOR
                        ARRAY_SEGMENT           { mout(MARRAYSEP);}
                ;
ARRAY_SEGMENT_EL:       HIDENTIFIER             { mout(MIDENTIFIER);
                                                  moutId($1);
                                                  regDecl($1, type, kind, categ);
				   if(lastArray==NULL)
                                     lastArray=cblock->lastparloc;}
                ;
BAUND_PAIR_LIST :       BAUND_PAIR              { mout(MENDSEP);
                                                  mout(MBOUNDSEP);
                                                  $$=1;}
                |       BAUND_PAIR
                        HPAREXPSEPARATOR
                        BAUND_PAIR_LIST         { mout(MBOUNDSEP);
                                                  $$=$3+1;}
                ;
BAUND_PAIR      :       EXPRESSION
                        HLABELSEPARATOR
                        EXPRESSION              { mout(MBOUNDPARSEP);}
                ;
SWITCH_LIST     :       EXPRESSION              { mout(MENDSEP);
                                                  mout(MSWITCHSEP);}
                |       EXPRESSION
                        HPAREXPSEPARATOR
                        SWITCH_LIST             { mout(MSWITCHSEP);}
                ;
HEADING         :       MBEE_FMAL_PAR_P HSTATEMENTSEPARATOR { kind=KNOKD;}
                        MBEE_MODE_PART  { categ=CSPEC;}
                        MBEE_SPEC_PART  { kind=KNOKD;}
                        MBEE_PROT_PART  { categ=CVIRT;}
                        MBEE_VIRT_PART
                                        { categ=CLOCAL;}
                ;
MBEE_FMAL_PAR_P :       /*EMPT*/
                |       FMAL_PAR_PART
                ;
FMAL_PAR_PART   :       HBEGPAR NO_TYPE
                        MBEE_LISTV HENDPAR
                ;
MBEE_LISTV      :       /*EMPT*/
                |       LISTV
                ;
LISTV           :       HIDENTIFIER     { regDecl($1, type, KNOKD, CDEFLT);}
                |	FPP_CATEG HDOTDOTDOT      { regDecl(varargsid, TVARARGS, KNOKD, categ);}
                |       HIDENTIFIER     { regDecl($1, type, KNOKD, CDEFLT);}
                        HPAREXPSEPARATOR LISTV
                |       FPP_SPEC
                |       FPP_SPEC
                        HPAREXPSEPARATOR LISTV
                ;
FPP_HEADING     :       HBEGPAR NO_TYPE
                        FPP_MBEE_LISTV HENDPAR
                ;
FPP_MBEE_LISTV  :       /*EMPT*/
                |       FPP_LISTV
                ;
FPP_LISTV       :	FPP_CATEG HDOTDOTDOT      { regDecl(varargsid, TVARARGS, KNOKD, categ);}
                |       FPP_SPEC
                |       FPP_SPEC
                        HPAREXPSEPARATOR LISTV
                ;
FPP_SPEC        :       FPP_CATEG SPECIFIER HIDENTIFIER
                                       { regDecl($3, type, kind, categ);}
		|	FPP_CATEG FPP_PROC_DECL_IN_SPEC
		;
FPP_CATEG       :       HNAME HLABELSEPARATOR
                                       { categ=CNAME;}
                |       HVALUE HLABELSEPARATOR
                                       { categ=CVALUE;}
                |       HVAR HLABELSEPARATOR
                                       { categ=CVAR;}
                |       /*EMPT*/       { categ=CDEFLT;}
                ;
FPP_PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
                        HIDENTIFIER
                                	{ $<ival>$=categ;
                                          regDecl($3, type, KPROC, categ);
                                          beginBlock(KPROC);}
                        FPP_HEADING
					{ categ=$<ival>4; /* M} settes tilbake*/}
				{ endBlock(NULL,CCNO);}
		;
IDENTIFIER_LISTV:       HIDENTIFIER     { regDecl($1, type, kind, categ);}
                |	HDOTDOTDOT {	  regDecl(varargsid, TVARARGS, kind, categ);}
                |       HIDENTIFIER     { regDecl($1, type, kind, categ);}
                        HPAREXPSEPARATOR IDENTIFIER_LISTV
                ;
MBEE_MODE_PART  :       /*EMPT*/
                |       MODE_PART
                ;
MODE_PART       :       NAME_PART
                |       VALUE_PART
                |       VAR_PART
                |       NAME_PART VALUE_PART
                |       VALUE_PART NAME_PART
                |       NAME_PART VAR_PART
                |       VAR_PART NAME_PART
                |       VALUE_PART VAR_PART
                |       VAR_PART VALUE_PART
                |       VAR_PART NAME_PART VALUE_PART
                |       NAME_PART VAR_PART VALUE_PART
                |       NAME_PART VALUE_PART VAR_PART
                |       VAR_PART VALUE_PART NAME_PART
                |       VALUE_PART VAR_PART NAME_PART
                |       VALUE_PART NAME_PART VAR_PART
                ;
NAME_PART       :       HNAME           { categ=CNAME;}
                        IDENTIFIER_LISTV
                        HSTATEMENTSEPARATOR
                ;
VAR_PART        :       HVAR            { categ=CVAR;}
                        IDENTIFIER_LISTV
                        HSTATEMENTSEPARATOR
                ;
VALUE_PART      :       HVALUE          { categ=CVALUE;}
                        IDENTIFIER_LISTV HSTATEMENTSEPARATOR
                ;
MBEE_SPEC_PART  :       /*EMPT*/
                |       SPEC_PART
                ;
SPEC_PART       :       ONE_SPEC
                |       SPEC_PART ONE_SPEC
                ;
ONE_SPEC	:	SPECIFIER IDENTIFIER_LIST HSTATEMENTSEPARATOR
		|	NO_TYPE HPROCEDURE HIDENTIFIER HOBJRELOPERATOR
			  { if($4!=HIS) yerror (8);}
			PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
                |       FPP_PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
                |       MBEE_TYPE HPROCEDURE HIDENTIFIER HSTATEMENTSEPARATOR
					{ yerror (45);}
                |       MBEE_TYPE HPROCEDURE HIDENTIFIER HPAREXPSEPARATOR
                        IDENTIFIER_LIST HSTATEMENTSEPARATOR
					{ yerror (45);}
		;
SPECIFIER       :       TYPE            { kind=KSIMPLE;}
                |       MBEE_TYPE
                        HARRAY          { kind=KARRAY;}
                |       HLABEL          { type=TLABEL;
                                          kind=KSIMPLE;}
                |       HSWITCH         { type=TLABEL;
                                          kind=KARRAY;}
                ;
PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
                        HIDENTIFIER
                                	{ $<ival>$=categ;
                                          regDecl($3, type, KPROC, categ);
                                          beginBlock(KPROC);}
                        HEADING
					{ categ=$<ival>4; /* M} settes tilbake*/}
			MBEE_BEGIN_END
				{ endBlock(NULL,CCNO);}
		;
MBEE_BEGIN_END	:	/* EMPTY */
		|	HBEGIN HEND
		;
MBEE_PROT_PART  :       /*EMPT*/
                |       PROTECTION_PART
                ;
PROTECTION_PART :       PROT_SPECIFIER IDENTIFIER_LIST
                        HSTATEMENTSEPARATOR
                |       PROTECTION_PART  PROT_SPECIFIER
                        IDENTIFIER_LIST HSTATEMENTSEPARATOR
                ;
PROT_SPECIFIER  :       HHIDDEN         { categ=CHIDEN;}
                |       HPROTECTED      { categ=CPROT;}
                |       HHIDDEN
                        HPROTECTED      { categ=CHIPRO;}
                |       HPROTECTED
                        HHIDDEN         { categ=CHIPRO;}
                ;
MBEE_VIRT_PART  :       /*EMPT*/
                |       VIRTUAL_PART
                ;
VIRTUAL_PART    :       HVIRTUAL
                        HLABELSEPARATOR
                        MBEE_SPEC_PART
                ;
IDENTIFIER_LIST :       HIDENTIFIER     { regDecl($1, type, kind, categ);}
                |       IDENTIFIER_LIST HPAREXPSEPARATOR
                        HIDENTIFIER     { regDecl($3, type, kind, categ);}
                ;
IDENTIFIER_LISTC:       HIDENTIFIER
			MBEE_CONSTANT   { regDecl($1, type, kind, categ);
					  categ=CLOCAL;}
                |       IDENTIFIER_LISTC HPAREXPSEPARATOR
                        HIDENTIFIER
			MBEE_CONSTANT   { regDecl($3, type, kind, categ);
					  categ=CLOCAL;}
                ;
MBEE_CONSTANT	:	/* EMPTY */
		|	HVALRELOPERATOR
				{ MBEENEWBLOCK();
			    if($1!=HEQ) yerror (8);
					  if(type==TREF)yerror (7);
					  categ=CCONSTU;
						  mout(MIDENTIFIER);
						  moutId($<token>0);}
			EXPRESSION		{ mout(MASSIGN);
						  mout(MCONST);}
		;

/* GRAMATIKK FOR UTTRYKK */
EXPRESSION      :       EXPRESSION_SIMP {}
                |       HIF
                        EXPRESSION
                        HTHEN
                        EXPRESSION
                        HELSE
                        EXPRESSION              { mout(MELSEE);
                                                  mout(MIFE);}
                ;
EXPRESSION_SIMP :	EXPRESSION_SIMP
			HASSIGN
			EXPRESSION { if($2==HASSIGNREF)mout(MASSIGNR);
                                          else    mout(MASSIGN);$$=NULL;}
		|

			EXPRESSION_SIMP
                        HCONC
                        EXPRESSION_SIMP         { mout(MCONC);$$=NULL;}
                |       EXPRESSION_SIMP HOR
                        HELSE
                        EXPRESSION_SIMP
                        %prec HORELSE           { mout(MORELSEE);$$=NULL;}
                |       EXPRESSION_SIMP HAND
                        HTHEN
                        EXPRESSION_SIMP
                        %prec HANDTHEN          { mout(MANDTHENE);$$=NULL;}
                |       EXPRESSION_SIMP
                        HEQV EXPRESSION_SIMP    { mout(MEQV);$$=NULL;}
                |       EXPRESSION_SIMP
                        HIMP EXPRESSION_SIMP    { mout(MIMP);$$=NULL;}
                |       EXPRESSION_SIMP
                        HOR EXPRESSION_SIMP     { mout(MOR);$$=NULL;}
                |       EXPRESSION_SIMP
                        HAND EXPRESSION_SIMP    { mout(MAND);$$=NULL;}
                |       HNOT EXPRESSION_SIMP    { mout(MNOT);$$=NULL;}
                |       EXPRESSION_SIMP
                        HVALRELOPERATOR
                        EXPRESSION_SIMP
                                { switch($2)
                                    {   case HEQ: mout(MEQ);break;
                                        case HNE: mout(MNE);break;
                                        case HLT: mout(MLT);break;
                                        case HLE: mout(MLE);break;
                                        case HGT: mout(MGT);break;
                                        case HGE: mout(MGE);break;
                                    }$$=NULL;}
                |       EXPRESSION_SIMP
                        HREFRELOPERATOR
                        EXPRESSION_SIMP
                                { if($2==HNER)    mout(MNER);
                                        else      mout(MEQR);$$=NULL;}
                |       EXPRESSION_SIMP
                        HOBJRELOPERATOR
                        EXPRESSION_SIMP
                                { if($2==HIS)     mout(MIS);
                                        else      mout(MINS);$$=NULL;}
                |       HTERMOPERATOR
                        EXPRESSION_SIMP %prec UNEAR
                                { if($1==HADD)    mout(MUADD);
                                        else      mout(MUSUB);$$=NULL;}
                |       EXPRESSION_SIMP
                        HTERMOPERATOR
                        EXPRESSION_SIMP
                                { if($2==HADD)    mout(MADD);
                                        else      mout(MSUB);$$=NULL;}
                |       EXPRESSION_SIMP
                        HFACTOROPERATOR
                        EXPRESSION_SIMP
                                { if($2==HMUL)    mout(MMUL); else
                                  if($2==HDIV)    mout(MDIV);
                                        else      mout(MINTDIV);$$=NULL;}
                |       EXPRESSION_SIMP
                        HPRIMARYOPERATOR
                        EXPRESSION_SIMP         { mout(MPRIMARY);$$=NULL;}
                |       HBEGPAR
                        EXPRESSION HENDPAR      { mout(MNOOP);$$=NULL;}
                |       HTEXTKONST              { mout(MTEXTKONST);
                                                  moutTval($1);$$=NULL;}
                |       HCHARACTERKONST         { mout(MCHARACTERKONST);
                                                  moutIval($1);$$=NULL;}
                |       HREALKONST              { mout(MREALKONST);
                                                  moutRval($1);$$=NULL;}
                |       HINTEGERKONST           { mout(MINTEGERKONST);
                                                  moutIval($1);$$=NULL;}
                |       HBOOLEANKONST           { mout(MBOOLEANKONST);
                                                  moutIval($1);$$=NULL;}
                |       HNONE                   { mout(MNONE);$$=NULL;}
                |       HIDENTIFIER
                                { $<ident>$=$1;}
                        MBEE_ARG_R_PT
                |       HTHIS HIDENTIFIER       { mout(MTHIS);
                                                  moutId($2);$$=NULL;}
                |       HNEW
                        HIDENTIFIER
                        ARG_R_PT                { mout(MNEWARG);
                                                  moutId($2);$$=NULL;}
                |       EXPRESSION_SIMP
                        HDOT
                        EXPRESSION_SIMP         { mout(MDOT);$$=NULL;}
                |       EXPRESSION_SIMP
                        HQUA HIDENTIFIER        { mout(MQUA);
                                                  moutId($3);$$=NULL;}
                ;
ARG_R_PT        :       /*EMPTY*/               { mout(MENDSEP);}
                |       HBEGPAR
                        ARGUMENT_LIST HENDPAR
                ;
MBEE_ARG_R_PT   :       /*EMPTY*/               { mout(MIDENTIFIER);
                                                  moutId($<ident>0);
						  $$=$<ident>0;}
                |       HBEGPAR
                        ARGUMENT_LIST HENDPAR   { mout(MARGUMENT);
                                                  moutId($<ident>0);}
                ;
ARGUMENT_LIST   :       EXPRESSION              { mout(MENDSEP);
                                                  mout(MARGUMENTSEP);}
                |       EXPRESSION
                        HPAREXPSEPARATOR
                        ARGUMENT_LIST           { mout(MARGUMENTSEP);}
                ;
%%
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
$at_traceoff
$at_verbose "torture.at:1294: bison --verbose --defines input.y"
echo torture.at:1294 >$at_check_line_file
( $at_traceon; bison --verbose --defines input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y contains 78 shift/reduce conflicts and 10 reduce/reduce conflicts.
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:1294: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "torture.at:1306: grep '^State.*contains' input.output"
echo torture.at:1306 >$at_check_line_file
( $at_traceon; grep '^State.*contains' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "State 62 contains 14 shift/reduce conflicts.
State 162 contains 1 shift/reduce conflict.
State 199 contains 33 shift/reduce conflicts and 4 reduce/reduce conflicts.
State 204 contains 1 shift/reduce conflict.
State 238 contains 1 shift/reduce conflict.
State 333 contains 9 shift/reduce conflicts and 2 reduce/reduce conflicts.
State 354 contains 1 shift/reduce conflict.
State 358 contains 9 shift/reduce conflicts and 2 reduce/reduce conflicts.
State 425 contains 9 shift/reduce conflicts and 2 reduce/reduce conflicts.
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:1306: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-7 ) # Banner 7. regression.at:19
    cat <<\_ATEOF

Regression tests.

_ATEOF
    ;;

  41 ) # 41. regression.at:26: %nonassoc and eof
    at_setup_line='regression.at:26'
    $at_verbose "41. regression.at:26: testing %nonassoc and eof..."
    $at_quiet $ECHO_N " 41: regression.at:26  $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'

%{
#include <stdio.h>

#define YYERROR_VERBOSE 1
#define yyerror(Msg) \
do { \
  fprintf (stderr, "%s\n", Msg); \
  exit (1); \
} while (0)

/* The current argument. */
static const char *input = NULL;

static int
yylex (void)
{
  /* No token stands for end of file. */
  if (input && *input)
    return *input++;
  else
    return 0;
}

%}

%nonassoc '<' '>'

%%
expr: expr '<' expr
    | expr '>' expr
    | '0'
    ;
%%
int
main (int argc, const char *argv[])
{
  if (argc > 1)
    input = argv[1];
  return yyparse ();
}
_ATEOF


# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "regression.at:73: bison input.y -o input.c"
echo regression.at:73 >$at_check_line_file
( $at_traceon; bison input.y -o input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:73: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "regression.at:74: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo regression.at:74 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:74: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "regression.at:76: ./input '0<0'"
echo regression.at:76 >$at_check_line_file
( $at_traceon; ./input '0<0' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:76: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# FIXME: This is an actual bug, but a new one, in the sense that
# no one has ever spotted it!  The messages are *wrong*: there should
# be nothing there, it should be expected eof.
$at_traceoff
$at_verbose "regression.at:82: ./input '0<0<0'"
echo regression.at:82 >$at_check_line_file
( $at_traceon; ./input '0<0<0' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error, unexpected '<', expecting '<' or '>'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "regression.at:82: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "regression.at:84: ./input '0>0'"
echo regression.at:84 >$at_check_line_file
( $at_traceon; ./input '0>0' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:84: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "regression.at:87: ./input '0>0>0'"
echo regression.at:87 >$at_check_line_file
( $at_traceon; ./input '0>0>0' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error, unexpected '>', expecting '<' or '>'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "regression.at:87: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "regression.at:91: ./input '0<0>0'"
echo regression.at:91 >$at_check_line_file
( $at_traceon; ./input '0<0>0' ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error, unexpected '>', expecting '<' or '>'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "regression.at:91: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  42 ) # 42. regression.at:100: braces parsing
    at_setup_line='regression.at:100'
    $at_verbose "42. regression.at:100: testing braces parsing..."
    $at_quiet $ECHO_N " 42: regression.at:100 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
/* Bison used to swallow the character after `}'. */

%%
exp: { tests = {{{{{{{{{{}}}}}}}}}}; };
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:110: bison -v input.y -o input.c"
echo regression.at:110 >$at_check_line_file
( $at_traceon; bison -v input.y -o input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:110: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "regression.at:112: fgrep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c"
echo regression.at:112 >$at_check_line_file
( $at_traceon; fgrep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:112: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  43 ) # 43. regression.at:122: Duplicate string
    at_setup_line='regression.at:122'
    $at_verbose "43. regression.at:122: testing Duplicate string..."
    $at_quiet $ECHO_N " 43: regression.at:122 $ECHO_C"
    (
      $at_traceon


cat >duplicate.y <<'_ATEOF'
/* `Bison -v' used to dump core when two tokens are defined with the same
   string, as LE and GE below. */

%token NUM
%token LE "<="
%token GE "<="

%%
exp: '(' exp ')' | NUM ;
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:137: bison -v duplicate.y -o duplicate.c"
echo regression.at:137 >$at_check_line_file
( $at_traceon; bison -v duplicate.y -o duplicate.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:137: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  44 ) # 44. regression.at:146: Unresolved SR Conflicts
    at_setup_line='regression.at:146'
    $at_verbose "44. regression.at:146: testing Unresolved SR Conflicts..."
    $at_quiet $ECHO_N " 44: regression.at:146 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "regression.at:156: bison input.y -o input.c -v"
echo regression.at:156 >$at_check_line_file
( $at_traceon; bison input.y -o input.c -v ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y contains 1 shift/reduce conflict.
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:156: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Check the contents of the report.
$at_traceoff
$at_verbose "regression.at:242: cat input.output"
echo regression.at:242 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "State 4 contains 1 shift/reduce conflict.


Grammar

  Number, Line, Rule
    1   3 exp -> exp OP exp
    2   3 exp -> NUM


Terminals, with rules where they appear

\$ (-1)
error (256)
NUM (257) 2
OP (258) 1


Nonterminals, with rules where they appear

exp (5)
    on left: 1 2, on right: 1


state 0

    NUM 	shift, and go to state 1

    exp 	go to state 2



state 1

    exp  ->  NUM .   (rule 2)

    \$default	reduce using rule 2 (exp)



state 2

    exp  ->  exp . OP exp   (rule 1)

    \$   	go to state 5
    OP  	shift, and go to state 3



state 3

    exp  ->  exp OP . exp   (rule 1)

    NUM 	shift, and go to state 1

    exp 	go to state 4



state 4

    exp  ->  exp . OP exp   (rule 1)
    exp  ->  exp OP exp .   (rule 1)

    OP  	shift, and go to state 3

    OP  	[reduce using rule 1 (exp)]
    \$default	reduce using rule 1 (exp)



state 5

    \$   	go to state 6



state 6

    \$default	accept


" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:242: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  45 ) # 45. regression.at:251: Solved SR Conflicts
    at_setup_line='regression.at:251'
    $at_verbose "45. regression.at:251: testing Solved SR Conflicts..."
    $at_quiet $ECHO_N " 45: regression.at:251 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%right OP
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "regression.at:260: bison input.y -o input.c -v"
echo regression.at:260 >$at_check_line_file
( $at_traceon; bison input.y -o input.c -v ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:260: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Check the contents of the report.
$at_traceoff
$at_verbose "regression.at:345: cat input.output"
echo regression.at:345 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Conflict in state 4 between rule 1 and token OP resolved as shift.


Grammar

  Number, Line, Rule
    1   4 exp -> exp OP exp
    2   4 exp -> NUM


Terminals, with rules where they appear

\$ (-1)
error (256)
NUM (257) 2
OP (258) 1


Nonterminals, with rules where they appear

exp (5)
    on left: 1 2, on right: 1


state 0

    NUM 	shift, and go to state 1

    exp 	go to state 2



state 1

    exp  ->  NUM .   (rule 2)

    \$default	reduce using rule 2 (exp)



state 2

    exp  ->  exp . OP exp   (rule 1)

    \$   	go to state 5
    OP  	shift, and go to state 3



state 3

    exp  ->  exp OP . exp   (rule 1)

    NUM 	shift, and go to state 1

    exp 	go to state 4



state 4

    exp  ->  exp . OP exp   (rule 1)
    exp  ->  exp OP exp .   (rule 1)

    OP  	shift, and go to state 3

    \$default	reduce using rule 1 (exp)



state 5

    \$   	go to state 6



state 6

    \$default	accept


" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:345: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  46 ) # 46. regression.at:356: Rule Line Numbers
    at_setup_line='regression.at:356'
    $at_verbose "46. regression.at:356: testing Rule Line Numbers..."
    $at_quiet $ECHO_N " 46: regression.at:356 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
expr:
'a'

{

}

'b'

{

}

|


{


}

'c'

{

};
_ATEOF


$at_traceoff
$at_verbose "regression.at:388: bison input.y -o input.c -v"
echo regression.at:388 >$at_check_line_file
( $at_traceon; bison input.y -o input.c -v ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:388: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Check the contents of the report.
$at_traceoff
$at_verbose "regression.at:490: cat input.output"
echo regression.at:490 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Grammar

  Number, Line, Rule
    1   2 @1 -> /* empty */
    2   2 expr -> 'a' @1 'b'
    3  15 @2 -> /* empty */
    4  15 expr -> @2 'c'


Terminals, with rules where they appear

\$ (-1)
'a' (97) 2
'b' (98) 2
'c' (99) 4
error (256)


Nonterminals, with rules where they appear

expr (6)
    on left: 2 4
@1 (7)
    on left: 1, on right: 2
@2 (8)
    on left: 3, on right: 4


state 0

    'a' 	shift, and go to state 1

    \$default	reduce using rule 3 (@2)

    expr	go to state 6
    @2  	go to state 2



state 1

    expr  ->  'a' . @1 'b'   (rule 2)

    \$default	reduce using rule 1 (@1)

    @1  	go to state 3



state 2

    expr  ->  @2 . 'c'   (rule 4)

    'c' 	shift, and go to state 4



state 3

    expr  ->  'a' @1 . 'b'   (rule 2)

    'b' 	shift, and go to state 5



state 4

    expr  ->  @2 'c' .   (rule 4)

    \$default	reduce using rule 4 (expr)



state 5

    expr  ->  'a' @1 'b' .   (rule 2)

    \$default	reduce using rule 2 (expr)



state 6

    \$   	go to state 7



state 7

    \$   	go to state 8



state 8

    \$default	accept


" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:490: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  47 ) # 47. regression.at:500: %expect not enough
    at_setup_line='regression.at:500'
    $at_verbose "47. regression.at:500: testing %expect not enough..."
    $at_quiet $ECHO_N " 47: regression.at:500 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 0
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "regression.at:512: bison input.y -o input.c"
echo regression.at:512 >$at_check_line_file
( $at_traceon; bison input.y -o input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y contains 1 shift/reduce conflict.
expected 0 shift/reduce conflicts
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "regression.at:512: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  48 ) # 48. regression.at:520: %expect right
    at_setup_line='regression.at:520'
    $at_verbose "48. regression.at:520: testing %expect right..."
    $at_quiet $ECHO_N " 48: regression.at:520 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 1
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "regression.at:529: bison input.y -o input.c"
echo regression.at:529 >$at_check_line_file
( $at_traceon; bison input.y -o input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:529: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  49 ) # 49. regression.at:537: %expect too much
    at_setup_line='regression.at:537'
    $at_verbose "49. regression.at:537: testing %expect too much..."
    $at_quiet $ECHO_N " 49: regression.at:537 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 2
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "regression.at:549: bison input.y -o input.c"
echo regression.at:549 >$at_check_line_file
( $at_traceon; bison input.y -o input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y contains 1 shift/reduce conflict.
expected 2 shift/reduce conflicts
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "regression.at:549: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  50 ) # 50. regression.at:558: Mixing %token styles
    at_setup_line='regression.at:558'
    $at_verbose "50. regression.at:558: testing Mixing %token styles..."
    $at_quiet $ECHO_N " 50: regression.at:558 $ECHO_C"
    (
      $at_traceon


# Taken from the documentation.
cat >input.y <<'_ATEOF'
%token  <operator>  OR      "||"
%token  <operator>  LE 134  "<="
%left  OR  "<="
%%
exp: ;
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:570: bison -v input.y -o input.c"
echo regression.at:570 >$at_check_line_file
( $at_traceon; bison -v input.y -o input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:570: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  51 ) # 51. regression.at:581: %union and --defines
    at_setup_line='regression.at:581'
    $at_verbose "51. regression.at:581: testing %union and --defines..."
    $at_quiet $ECHO_N " 51: regression.at:581 $ECHO_C"
    (
      $at_traceon


cat >union.y <<'_ATEOF'
%union
{
  int   integer;
  char *string ;
}
%%
exp: {};
_ATEOF


$at_traceoff
$at_verbose "regression.at:593: bison --defines union.y"
echo regression.at:593 >$at_check_line_file
( $at_traceon; bison --defines union.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:593: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  52 ) # 52. regression.at:603: %union and C comments
    at_setup_line='regression.at:603'
    $at_verbose "52. regression.at:603: testing %union and C comments..."
    $at_quiet $ECHO_N " 52: regression.at:603 $ECHO_C"
    (
      $at_traceon


cat >union-comment.y <<'_ATEOF'
%union
{
  /* The int.  */	int   integer;
  /* The string.  */	char *string ;
}
%%
exp: {};
_ATEOF


$at_traceoff
$at_verbose "regression.at:615: bison union-comment.y"
echo regression.at:615 >$at_check_line_file
( $at_traceon; bison union-comment.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:615: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "regression.at:616: fgrep '//*' union-comment.tab.c"
echo regression.at:616 >$at_check_line_file
( $at_traceon; fgrep '//*' union-comment.tab.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "regression.at:616: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  53 ) # 53. regression.at:626: Invalid inputs
    at_setup_line='regression.at:626'
    $at_verbose "53. regression.at:626: testing Invalid inputs..."
    $at_quiet $ECHO_N " 53: regression.at:626 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
?
default: 'a' }
%{
%&
%a
%-
_ATEOF


$at_traceoff
$at_verbose "regression.at:645: bison input.y"
echo regression.at:645 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:2: invalid input: \`?'
input.y:3: invalid input: \`}'
input.y:4: invalid input: \`%{'
input.y:5: invalid input: \`%&'
input.y:6: invalid input: \`%a'
input.y:7: invalid input: \`%-'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "regression.at:645: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  54 ) # 54. regression.at:656: Invalid %directive
    at_setup_line='regression.at:656'
    $at_verbose "54. regression.at:656: testing Invalid %directive..."
    $at_quiet $ECHO_N " 54: regression.at:656 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%invalid
_ATEOF


$at_traceoff
$at_verbose "regression.at:666: bison input.y"
echo regression.at:666 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:1: unrecognized: %invalid
input.y:1:    Skipping to next %
input.y:2: fatal error: no input grammar
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "regression.at:666: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  55 ) # 55. regression.at:681: Web2c Report
    at_setup_line='regression.at:681'
    $at_verbose "55. regression.at:681: testing Web2c Report..."
    $at_quiet $ECHO_N " 55: regression.at:681 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token	undef_id_tok const_id_tok

%start CONST_DEC_PART

%%
CONST_DEC_PART:
         CONST_DEC_LIST
        ;

CONST_DEC_LIST:
	  CONST_DEC
        | CONST_DEC_LIST CONST_DEC
        ;

CONST_DEC:
	  { } undef_id_tok '=' const_id_tok ';'
        ;
%%

_ATEOF


$at_traceoff
$at_verbose "regression.at:705: bison -v input.y"
echo regression.at:705 >$at_check_line_file
( $at_traceon; bison -v input.y ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:705: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "regression.at:771: sed -n 's/  *\$//;/^\$/!p' input.output"
echo regression.at:771 >$at_check_line_file
( $at_traceon; sed -n 's/  *$//;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Grammar
  Number, Line, Rule
    1   6 CONST_DEC_PART -> CONST_DEC_LIST
    2  10 CONST_DEC_LIST -> CONST_DEC
    3  12 CONST_DEC_LIST -> CONST_DEC_LIST CONST_DEC
    4  15 @1 -> /* empty */
    5  15 CONST_DEC -> @1 undef_id_tok '=' const_id_tok ';'
Terminals, with rules where they appear
\$ (-1)
';' (59) 5
'=' (61) 5
error (256)
undef_id_tok (257) 5
const_id_tok (258) 5
Nonterminals, with rules where they appear
CONST_DEC_PART (7)
    on left: 1
CONST_DEC_LIST (8)
    on left: 2 3, on right: 1 3
CONST_DEC (9)
    on left: 5, on right: 2 3
@1 (10)
    on left: 4, on right: 5
state 0
    \$default	reduce using rule 4 (@1)
    CONST_DEC_PART	go to state 9
    CONST_DEC_LIST	go to state 1
    CONST_DEC	go to state 2
    @1  	go to state 3
state 1
    CONST_DEC_PART  ->  CONST_DEC_LIST .   (rule 1)
    CONST_DEC_LIST  ->  CONST_DEC_LIST . CONST_DEC   (rule 3)
    undef_id_tok	reduce using rule 4 (@1)
    \$default	reduce using rule 1 (CONST_DEC_PART)
    CONST_DEC	go to state 4
    @1  	go to state 3
state 2
    CONST_DEC_LIST  ->  CONST_DEC .   (rule 2)
    \$default	reduce using rule 2 (CONST_DEC_LIST)
state 3
    CONST_DEC  ->  @1 . undef_id_tok '=' const_id_tok ';'   (rule 5)
    undef_id_tok	shift, and go to state 5
state 4
    CONST_DEC_LIST  ->  CONST_DEC_LIST CONST_DEC .   (rule 3)
    \$default	reduce using rule 3 (CONST_DEC_LIST)
state 5
    CONST_DEC  ->  @1 undef_id_tok . '=' const_id_tok ';'   (rule 5)
    '=' 	shift, and go to state 6
state 6
    CONST_DEC  ->  @1 undef_id_tok '=' . const_id_tok ';'   (rule 5)
    const_id_tok	shift, and go to state 7
state 7
    CONST_DEC  ->  @1 undef_id_tok '=' const_id_tok . ';'   (rule 5)
    ';' 	shift, and go to state 8
state 8
    CONST_DEC  ->  @1 undef_id_tok '=' const_id_tok ';' .   (rule 5)
    \$default	reduce using rule 5 (CONST_DEC)
state 9
    \$   	go to state 10
state 10
    \$   	go to state 11
state 11
    \$default	accept
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:771: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  56 ) # 56. regression.at:798: Web2c Actions
    at_setup_line='regression.at:798'
    $at_verbose "56. regression.at:798: testing Web2c Actions..."
    $at_quiet $ECHO_N " 56: regression.at:798 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
statement:  struct_stat;
struct_stat:  /* empty. */ | if else;
if: "if" "const" "then" statement;
else: "else" statement;
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:809: bison -v input.y -o input.c"
echo regression.at:809 >$at_check_line_file
( $at_traceon; bison -v input.y -o input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:809: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Check only the tables.  We don't use --no-parser, because it is
# still to be implemented in the experimental branch of Bison.
$at_traceoff
$at_verbose "regression.at:896: sed -n 's/  *\$//;/^static const.*\\[\\] =/,/^}/p' input.c"
echo regression.at:896 >$at_check_line_file
( $at_traceon; sed -n 's/  *$//;/^static const.*\[\] =/,/^}/p' input.c ) >$at_stdout 2>$at_stder1
at_status=$?
egrep '^ *\+' $at_stder1 >&2
egrep -v '^ *\+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "static const char yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
       6
};
static const short yyprhs[] =
{
       0,     0,     2,     3,     6,    11
};
static const short yyrhs[] =
{
       8,     0,     0,     9,    10,     0,     3,     4,     5,     7,
       0,     6,     7,     0
};
static const short yyrline[] =
{
       0,     2,     3,     3,     4,     5
};
static const char *const yytname[] =
{
  \"\$\", \"error\", \"\$undefined.\", \"\\\"if\\\"\", \"\\\"const\\\"\", \"\\\"then\\\"\",
  \"\\\"else\\\"\", \"statement\", \"struct_stat\", \"if\", \"else\", 0
};
static const short yyr1[] =
{
       0,     7,     8,     8,     9,    10
};
static const short yyr2[] =
{
       0,     1,     0,     2,     4,     2
};
static const short yydefact[] =
{
       2,     0,     1,     0,     0,     2,     3,     2,     5,     4,
       0,     0,     0
};
static const short yydefgoto[] =
{
       8,     2,     3,     6
};
static const short yypact[] =
{
      -2,    -1,-32768,    -4,     1,    -2,-32768,    -2,-32768,-32768,
       4,     5,-32768
};
static const short yypgoto[] =
{
       0,-32768,-32768,-32768
};
static const short yytable[] =
{
      10,     1,     5,     4,    11,    12,     7,     9
};
static const short yycheck[] =
{
       0,     3,     6,     4,     0,     0,     5,     7
};
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:896: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  * )
    echo "$as_me: no such test group: $at_group" >&2
    continue
    ;;
  esac

  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd $at_suite_dir

  case $at_group in
    banner-*) ;;
    *)
      if test ! -f $at_check_line_file; then
        sed "s/^ */$as_me: warning: /" <<_ATEOF
        A failure happened in a test group before any test could be
        run. This means that test suite is improperly designed.  Please
        report this failure to <bug-bison@gnu.org>.
_ATEOF
    	echo "$at_setup_line" >$at_check_line_file
      fi
      at_group_count=`expr 1 + $at_group_count`
      $at_verbose $ECHO_N "$at_group. $at_setup_line: $ECHO_C"
      case $at_status in
        0)  at_msg="ok"
            at_pass_list="$at_pass_list $at_group"
            # Cleanup the group directory, unless the user wants the files.
            $at_debug_p || rm -rf $at_group_dir
            ;;
        77) at_msg="ok (skipped near \``cat $at_check_line_file`')"
            at_skip_list="$at_skip_list $at_group"
            # Cleanup the group directory, unless the user wants the files.
            $at_debug_p || rm -rf $at_group_dir
            ;;
        *)  at_msg="FAILED near \``cat $at_check_line_file`'"
            at_fail_list="$at_fail_list $at_group"
            # Up failure, keep the group directory for autopsy.
            # Create the debugging script.
            {
              echo "#! /bin/sh"
              echo "cd $at_dir"
              echo 'exec ${CONFIG_SHELL-'"$SHELL"'}' "$0" \
                   '-v -d' "$at_debug_args" "$at_group" '${1+"$@"}'
              echo 'exit 1'
            } >$at_group_dir/run
            chmod +x $at_group_dir/run
            ;;
      esac
      echo $at_msg
      at_log_msg="$at_group. $at_setup_line: $at_msg"
      # If the group failed, $at_times_file is not available.
      test -f $at_times_file &&
        at_log_msg="$at_log_msg	(`sed 1d $at_times_file`)"
      echo "$at_log_msg" >&6
      $at_errexit_p && test -n "$at_fail_list" && break
      ;;
  esac
done

# Back to the top directory, in particular because we might
# rerun the suite verbosely.
cd $at_dir

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`(date +%s) 2>/dev/null`
echo "$as_me: ending at: $at_stop_date" >&6
at_duration_s=`(expr $at_stop_time - $at_start_time) 2>/dev/null`
at_duration_m=`(expr $at_duration_s / 60) 2>/dev/null`
at_duration_h=`(expr $at_duration_m / 60) 2>/dev/null`
at_duration_s=`(expr $at_duration_s % 60) 2>/dev/null`
at_duration_m=`(expr $at_duration_m % 60) 2>/dev/null`
at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
if test "$at_duration" != "h m s"; then
  echo "$as_me: test suite duration: $at_duration" >&6
fi

# Wrap up the test suite with summary statistics.
at_skip_count=`set dummy $at_skip_list; shift; echo $#`
at_fail_count=`set dummy $at_fail_list; shift; echo $#`
if test $at_fail_count = 0; then
  if test $at_skip_count = 0; then
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## All $at_group_count tests were successful. ##
_ASBOX
  else
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## All $at_group_count tests were successful ($at_skip_count skipped). ##
_ASBOX
  fi
elif test $at_debug_p = false; then
  if $at_errexit_p; then
    cat <<\_ASBOX
## ------------------------------------------------------------ ##
## ERROR: One of the tests failed, inhibiting subsequent tests. ##
## ------------------------------------------------------------ ##
_ASBOX
  else
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## ERROR: Suite unsuccessful, $at_fail_count of $at_group_count tests failed. ##
_ASBOX
  fi

  # Normalize the names so that `ls' lists them in order.
  echo 'You may investigate any problem if you feel able to do so, in which'
  echo 'case the test suite provides a good starting point.'
  echo
  echo 'Now, failed tests will be executed again, verbosely, and logged'
  echo 'in the file '$as_me'.log.'

  {
    echo
    echo
    cat <<\_ASBOX
## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##
_ASBOX

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL $0 $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL $0 $at_skip_list --list
      echo
    fi
    echo

    cat <<\_ASBOX
## --------------------------------------- ##
## Verbosely re-running the failing tests. ##
## --------------------------------------- ##
_ASBOX
    echo
  } >&6

  exec 6>/dev/null
  $SHELL $0 -v -d $at_debug_args $at_fail_list 2>&1 | tee -a $as_me.log
  exec 6>>$as_me.log

  {
    echo
    if test -n "$at_top_srcdir"; then
      cat <<\_ASBOX
## ------------------- ##
## Configuration logs. ##
## ------------------- ##
_ASBOX
      echo
      for at_file in `find "$at_top_srcdir" -name config.log -print`
      do
  	echo "$as_me: $at_file:"
  	sed 's/^/| /' $at_file
  	echo
      done
    fi
  } >&6


  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log is created. ##
_ASBOX

  echo
  echo "Please send \`$as_me.log' and all information you think might help:"
  echo
  echo "   To: <bug-bison@gnu.org>"
  echo "   Subject: [GNU Bison 1.35] $as_me.log: $at_fail_count failures"
  echo
  exit 1
fi

exit 0

